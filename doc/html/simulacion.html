<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>simulacion API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>simulacion</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
from enum import Enum
import matplotlib.pyplot as plt
from scipy import signal
from scipy.io import savemat
import numpy as np
from shapely import Polygon, Point


class InputError(Exception):
    pass


class LoadingError(Exception):
    pass


class OutOfBounds(Exception):
    pass


class MissingParameterError(Exception):
    pass


class ObjectCreationError(Exception):
    pass


class TipoElectrodo(Enum):
    punto = &#39;punto&#39;
    circulo = &#39;circulo&#39;
    poligono = &#39;poligono&#39;


class FormaDePloteo(Enum):
    fibras_sin_diametro = &#39;fibras_sin_diametro&#39;
    fibras_con_diametro = &#39;fibras_con_diametro&#39;


class PoblacionNervio(Enum):
    uniforme_con_superposicion = &#39;uniforme_con_superposicion&#39;
    uniforme_sin_superposicion = &#39;uniforme_sin_superposicion&#39;
    manual = &#39;manual&#39;
    desde_archivo = &#39;desde_archivo&#39;


class VariacionNodos(Enum):
    uniforme = &#39;uniforme&#39;
    normal = &#39;normal&#39;


class TipoEstimulo(Enum):
    potencial_de_accion = &#39;potencial_de_accion&#39;
    cuadrado = &#39;cuadrado&#39;
    manual = &#39;manual&#39;
    desde_archivo = &#39;desde_archivo&#39;


class TipoFibra(Enum):
    puntual = &#39;puntual&#39;
    no_puntual = &#39;no_puntual&#39;


def distancia_entre_puntos(x1, y1, x2, y2):
    &#34;&#34;&#34;Función que mide la distancia entre dos puntos.

    Args:
        x1 (float): Coordenada x del primer punto. 
        y1 (float): Coordenada y del primer punto.
        x2 (float): Coordenada x del segundo punto.
        y2 (float): Coordenada y del segundo punto.

    Returns:
        float: La función devuelve la distancia entre los dos puntos.
    &#34;&#34;&#34;
    return np.sqrt((x1 - x2)**2 + (y1 - y2)**2)


def distancia_entre_circulos(x1, y1, radio1, x2, y2, radio2):
    &#34;&#34;&#34;Método que devuelve la distancia entre dos círculos.

    Args:
        x1 (float): Coordenada x del centro del primer círculo.
        y1 (float): Coordenada y del centro del primer círculo.
        radio1 (float): Radio del primer círculo.
        x2 (float): Coordenada x del centro del segundo círculo.
        y2 (float): Coordenada y del centro del segundo círculo.
        radio2 (float): Radio del segundo círculo.

    Returns:
        float: Devuelve el cálculo de la distancia entre los dos círculos.
    &#34;&#34;&#34;
    return (distancia_entre_puntos(x1=x1, y1=y1, x2=x2, y2=y2)) - radio1 - radio2


def is_inside_circencirc(r1, x1, y1, r0, x0, y0):
    &#34;&#34;&#34;Función con la que se evalúa si un primer círculo (x1,y1,r1) se encuentra dentro de un segundo círculo (x0,y0,r0).

    Args:
        r1 (float): Radio del primer círculo.
        x1 (float): Coordenada x del centro del primer círculo.
        y1 (float): Coordenada y del centro del primer círculo.
        r0 (float): Radio del círculo al que se le evalúa si contiene al primer círculo.
        x0 (float, optional): Coordenada x del centro del círculo al que se le evalúa si contiene al primer círculo. Por defecto es 0.
        y0 (float, optional): Coordenada y del centro del círculo al que se le evalúa si contiene al primer círculo. Por defecto es 0.

    Returns:
        bool: Devuelve True o False de acuerdo a si el primer círculo está contenido dentro del segundo o no.
    &#34;&#34;&#34;
    return r0 &gt;= r1 + distancia_entre_puntos(x1=x1, y1=y1, x2=x0, y2=y0)


def funcion_trapecio(x, z, d, a):
    &#34;&#34;&#34;Función trapecio. Devuelve el valor de la función trapecio para un dado x.

    Args:
        x (float): Valor en el cual se evaluará la función trapecio.
        z (float): Centro simétrico del trapecio.
        d (float): La mitad del valor del largo inferior del trapecio.
        a (float): La mitad del largo superior del trapecio.

    Returns:
        float: Devuelve el valor de la función evaluado en un dado x.
    &#34;&#34;&#34;
    if (x &gt; z - d - a and x &lt; z - a):
        return (x - z + d + a) / d
    if (x &gt; z + a and x &lt; z + a + d):
        return (z + a + d - x) / d
    if (x &gt;= z - a and x &lt;= z + a):
        return 1
    return 0


def funcion_gaussiana(x, z, d, a):
    &#34;&#34;&#34;Función exponencial con caída como una función gaussiana. 

    Args:
        x (float): Valor en el cual se evaluará la función.
        z (float): mu, esperanza de la función gaussiana.
        d (float): Valor hasta el cual se quiere lograr la caída de la función.
        a (float): Valor hasta el cual se quiere mantener la función igual a 1.

    Returns:
        float: Devuelve el valor de la función evaluado en un dado x.
    &#34;&#34;&#34;
    if (x &gt; z - d - a and x &lt; z - a):
        exponente = -(x - (z - a))**2 / (2 * (d / 3)**2)
        return np.exp(exponente)
    if (x &gt; z + a and x &lt; z + a + d):
        exponente = -(x - (z + a))**2 / (2 * (d / 3)**2)
        return np.exp(exponente)
    if (x &gt;= z - a and x &lt;= z + a):
        return 1
    return 0


def funcion_constante(x, z, d, a, v):
    &#34;&#34;&#34;Función que devuelve un valor constante en un cierto rango.

    Args:
        x (float): Valor en el cual se evaluará la función.
        z (float): Centro del intervalo.
        d (float): Valor del ancho del intervalo, hacia izquierda o derecha.
        a (float): Extensión para el ancho del intervalo, hacia izquierda o derecha.
        valor (float): El valor de la función cuando no es cero.

    Returns:
        float: Devuelve el valor de la función evaluado en un dado x.
    &#34;&#34;&#34;
    if x &gt;= z - d - a and x &lt;= z + d + a:
        return v

    return 0


def insertar_estimulo(estimulo, posicion, fm, tiempo_registro, velocidad, peso):
    &#34;&#34;&#34;Función que desplaza un numpy array dada una posición de inicio.

    Args:
        estimulo (numpy.ndarray): Señal que es desplazada.
        posicion (float): Posición hasta la que se desplaza el inicio del estímulo. En micrometros.
        fm (float): Frecuencia de muestreo de la señal. En Hz.
        tiempo_registro (float): Tiempo total en el que se hará el registro. En segundos.
        velocidad (float): Velocidad a la cual se desplaza la señal. En m/s.
        peso (float): Factor por el cual se multiplica la señal.

    Returns:
        numpy.ndarray: Devuelve el estímulo desplazado, en el tiempo de registro.
    &#34;&#34;&#34;
    total_muestras = int(tiempo_registro * fm)
    muestras_estimulo = len(estimulo)
    vector = np.zeros(total_muestras)
    inicio = int((posicion * fm) / (velocidad * 1000000))  #retardo

    if inicio &lt; total_muestras and peso != 0:
        if muestras_estimulo &gt; (total_muestras - inicio):
            muestras_estimulo = total_muestras - inicio
        vector[inicio:inicio + muestras_estimulo] = estimulo[0:muestras_estimulo] * peso
        return vector

    return None


def array_to_multiarray(array, estimulo, fm, tiempo_registro, velocidad, peso):
    &#34;&#34;&#34;Función que, dado un array con posiciones, crea un array de arrays, con estímulos desplazados para cada posición.

    Args:
        array (numpy.ndarray): Array que contiene las posiciones con las cuales se hará el desplazamiento del estímulo.
        estimulo (numpy.ndarray): Señal que es desplazada.
        fm (float): Frecuencia de muestreo. En Hz.
        tiempo_registro (float): Tiempo total en el que se hará el registro. En segundos.
        velocidad (float): Velocidad a la cual se desplaza la señal. En m/s.
        peso (float): Factor por el cual se multiplica la señal. 

    Returns:
        numpy.ndarray: Devuelve el array de arrays con los estímulos desplazados.
    &#34;&#34;&#34;
    total_muestras = int(tiempo_registro * fm)
    multiarray = np.zeros((len(array), total_muestras))
    for i, posicion in enumerate(array):
        vector = insertar_estimulo(estimulo=estimulo,
                                   posicion=posicion,
                                   fm=fm,
                                   tiempo_registro=tiempo_registro,
                                   velocidad=velocidad,
                                   peso=peso[i])
        if vector is not None:
            multiarray[i] = vector
    return multiarray


class Nervio:
    &#34;&#34;&#34;Nervio.
    &#34;&#34;&#34;

    def __init__(self, diametro, longitud, conductividad_transversal=None, porcentaje_cobertura=None):
        &#34;&#34;&#34;Método constructor de la clase Nervio.

        Args:
            diametro (int): Diametro del nervio en micrómetros.
            longitud (int): Longitud del nervio en micrometros.
            conductividad_transversal (float, optional): Conductividad transversal del nervio. Por defecto None.
            porcentaje_cobertura (float, optional): Porcentaje del nervio al cual llega el electrodo. Por defecto None.

        Raises:
            InputError: Se levanta este error si no se ingresa un valor de conductividad_transversal o de pocentaje_cobertura, dado que uno de los dos es necesario para realizar cálculos posteriores.
        &#34;&#34;&#34;
        self.radio = diametro / 2
        self.longitud_nervio = longitud
        self.conductividad_transversal = conductividad_transversal
        self.porcentaje_cobertura = porcentaje_cobertura
        self.fibras = []
        self.cantidad_fibras = 0
        self.limite_lateral_izquierdo = -self.radio
        self.limite_lateral_derecho = self.radio
        self.limite_superior = self.radio
        self.limite_inferior = -self.radio
        self.centro_nervio_x = 0
        self.centro_nervio_y = 0
        self.informacion_nodos = []
        self.metodo_poblacion = None
        self.distancia_nodos_promedio = None

        if self.conductividad_transversal is None and self.porcentaje_cobertura is None:
            raise InputError(
                &#34;Se debe ingresar ya sea un valor de conductividad transversal o un porcentaje de cobertura.&#34;)

    def info_nervio(self):
        &#34;&#34;&#34;Método que devuelve un diccionario con información del nervio.

        Returns:
            dict: Diccionario con información del nervio.
        &#34;&#34;&#34;
        return {
            &#34;diametro&#34;: 2 * self.radio,
            &#34;cantidad_fibras&#34;: self.cantidad_fibras,
            &#34;longitud&#34;: self.longitud_nervio,
            &#34;posicion_centro_nervio&#34;: [self.centro_nervio_x, self.centro_nervio_y],
            &#34;conductividad_transversal&#34;: self.conductividad_transversal,
            &#34;porcentaje_de_cobertura&#34;: self.porcentaje_cobertura
        }

    def informacion_fibras(self):
        &#34;&#34;&#34;Método para obtener una lista con la información de las fibras dentro del nervio.

        Returns:
            numpy.ndarray: Devuelve un array cuyas dos primeras columnas son las coordenadas x e y de cada fibra, y la tercera columna contiene información del diámetro de las fibras.
        &#34;&#34;&#34;
        return np.array([fibra.obtener_info_fibra() for fibra in self.fibras])

    def poblar(self,
               num_fibras,
               diametro_fibra,
               var_diametro,
               metodo_poblacion=&#39;uniforme_con_superposicion&#39;,
               semilla=None,
               alfa=7.6,
               velocidad=None,
               **kwargs):
        &#34;&#34;&#34;Método para poblar el nervio con las fibras nerviosas.

        Args:
            num_fibras (int): Número de fibras que contendrá el nervio.
            diametro_fibra (float): Diámetro de la fibra en micrones.
            var_diametro (int): La variación del diámetro se hace con la función normal, por lo que este es el sigma.
            metodo_poblacion (str, optional): Tipo de método de población de fibras en el nervio. Por defecto es &#39;uniforme&#39;.
            semilla (int, optional): Número de la semilla. Por defecto es None.
            alfa (float, optional): Valor para calcular la velocidad de conducción de las fibras. Por defecto es 7.6. En [m/s/micrómetro]
            velocidad (float,optional): Velocidad de la fibra en [m/s].
        
        Keyword Args:
            array_fibras (numpy.ndarray): Numpy array con 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra, en el método de población manual.
            ubicacion_archivo (str): String con la ubicación del archivo csv para el método de población desde_archivo. El archivo csv debe contener 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra.

        Raises:
            InputError: Si el método de población ingresado no se encuentra entre las opciones disponibles.
        &#34;&#34;&#34;
        self.metodo_poblacion = metodo_poblacion
        if metodo_poblacion == PoblacionNervio.uniforme_con_superposicion.name:
            if diametro_fibra is None:
                raise InputError(&#39;Se debe ingresar un diámetro de fibra.&#39;)
            self.uniforme_con_superposicion(num_fibras=num_fibras,
                                            diametro_fibra=diametro_fibra,
                                            var_diametro=var_diametro,
                                            semilla=semilla,
                                            alfa=alfa,
                                            velocidad=velocidad)
        elif metodo_poblacion == PoblacionNervio.uniforme_sin_superposicion.name:
            if diametro_fibra is None:
                raise InputError(&#39;Se debe ingresar un diámetro de fibra.&#39;)
            self.uniforme_sin_suporsicion(num_fibras=num_fibras,
                                          diametro_fibra=diametro_fibra,
                                          var_diametro=var_diametro,
                                          semilla=semilla,
                                          alfa=alfa,
                                          velocidad=velocidad)
        elif metodo_poblacion == PoblacionNervio.manual.name:
            self.manual(array_fibras=kwargs.get(&#39;array_fibras&#39;, None))
        elif metodo_poblacion == PoblacionNervio.desde_archivo.name:
            self.desde_archivo(ubicacion_archivo=kwargs.get(&#39;ubicacion_archivo&#39;, None))
        else:
            raise InputError(&#39;El método de población ingresado no es correcto.&#39;)

    def uniforme_con_superposicion(self, num_fibras, diametro_fibra, var_diametro, semilla, alfa, velocidad):
        &#34;&#34;&#34;Función para poblar el nervio con distribución uniforme, con superposición de las fibras.

        Args:
            num_fibras (int): Número de fibras que contendrá el nervio.
            diametro_fibra (float): Diámetro de la fibra en micrones.
            var_diametro (int): La variación del diámetro se hace con la función normal, por lo que este es el sigma.
            semilla (int): Número de la semilla.
            alfa (float): Valor para calcular la velocidad de conducción de las fibras.
            velocidad (float): Velocidad de la fibra en [m/s].
        &#34;&#34;&#34;
        #Tiene centro en (0,0), implementar el traslado
        np.random.seed(semilla)
        longitud = np.random.uniform(0, self.radio**2, size=num_fibras)
        angulo = np.pi * np.random.uniform(0, 2, size=num_fibras)
        diam = []
        while len(diam) &lt; num_fibras:
            diametro = np.random.normal(diametro_fibra, var_diametro)
            if diametro &gt; 0:
                diam.append(diametro)
        x = np.sqrt(longitud) * np.cos(angulo)
        y = np.sqrt(longitud) * np.sin(angulo)
        matriz = np.column_stack((x, y, np.array(diam)))
        self.fibras = [
            Fibra(x=x, y=y, diametro=diam, velocidad=alfa *
                  diam) if velocidad is None else Fibra(x=x, y=y, diametro=diam, velocidad=velocidad)
            for x, y, diam in matriz
        ]
        self.cantidad_fibras = num_fibras

    def uniforme_sin_suporsicion(self, num_fibras, diametro_fibra, var_diametro, semilla, alfa, velocidad):
        &#34;&#34;&#34;Función para poblar el nervio con distribución uniforme, sin superposición de las fibras.

        Args:
            num_fibras (int): Número de fibras que contendrá el nervio.
            diametro_fibra (float): Diámetro de la fibra en micrones.
            var_diametro (int): La variación del diámetro se hace con la función normal, por lo que este es el sigma.
            semilla (int): Número de la semilla.
            alfa (float): Valor para calcular la velocidad de conducción de las fibras.
            velocidad (float): Velocidad de la fibra en [m/s].
        &#34;&#34;&#34;
        np.random.seed(semilla)
        lista = []

        while len(lista) &lt; num_fibras:
            choque = False
            length = np.random.uniform(0, self.radio**2)
            angle = np.pi * np.random.uniform(0, 2)
            diam = np.random.normal(diametro_fibra, var_diametro)
            while diam &lt;= 0:
                diam = np.random.normal(diametro_fibra, var_diametro)
            x = np.sqrt(length) * np.cos(angle)
            y = np.sqrt(length) * np.sin(angle)

            for a, b, c in lista:
                if distancia_entre_circulos(x, y, diam / 2, a, b, c / 2) &lt; 0:
                    choque = True
            if choque is False and is_inside_circencirc(diam / 2, x, y, self.radio, self.centro_nervio_x,
                                                        self.centro_nervio_y):
                lista.append([x, y, diam])

        self.fibras = [
            Fibra(x=x, y=y, diametro=diam, velocidad=alfa *
                  diam) if velocidad is None else Fibra(x=x, y=y, diametro=diam, velocidad=velocidad)
            for x, y, diam in lista
        ]
        self.cantidad_fibras = num_fibras

    def manual(self, array_fibras):
        &#34;&#34;&#34;Función para poblar el nervio de forma manual, a partir de un array con la posición de las fibras, y sus diámetros.

        Args:
            array_fibras (numpy.ndarray): Array con la posición y diámetros de las fibras, si lo tuviera.
            
        Raises:
            ValueError: Valor que se levanta cuando se encuentra que en el array ingresado no se encuentran todos los parámetros necesarios.
            OutOfBounds: Error que se levanta si se encuentra que alguna de las fibras ingresadas supera los límites del nervio.
        &#34;&#34;&#34;
        try:
            f = [
                Fibra(x, y, d, v)
                for x, y, d, v in array_fibras
                if is_inside_circencirc(d / 2, x, y, self.radio, self.centro_nervio_x, self.centro_nervio_y)
            ]
        except ValueError as exc:
            raise ValueError(
                &#39;Se necesitan los datos de ubicación de fibras en eje x e y, diámetros y velocidades para este método.&#39;
            ) from exc

        if len(f) != len(array_fibras):
            raise OutOfBounds(&#34;Se encontró por lo menos una fibra fuera de los límites del nervio.&#34;)

        self.fibras = f
        self.cantidad_fibras = len(array_fibras)

    def desde_archivo(self, ubicacion_archivo):
        &#34;&#34;&#34;Función para poblar un nervio, a partir de un archivo csv.

        Args:
            ubicacion_archivo (str): String con la ubicación del archivo csv.
            
        Raises:
            LoadingError: Error que se levanta cuando no se puede cargar el archivo.
            ValueError: Error que se levanta cuando se detecta que algún caracter ingresado en el archivo no es numérico.
        &#34;&#34;&#34;
        try:
            fibras = np.genfromtxt(ubicacion_archivo, delimiter=&#39;,&#39;)
        except Exception as e:
            raise LoadingError(&#39;Fallo en carga de archivo.&#39;) from e

        if not np.isnan(sum(fibras)).any() and np.issubdtype(fibras.dtype, np.number):
            self.manual(array_fibras=fibras)
        else:
            raise ValueError(&#34;La lista contiene caracteres que no son números.&#34;)

    def ploteo_fibras_puntos(self, borde_nervio=&#39;blue&#39;, relleno_nervio=&#39;None&#39;, color_fibras=&#39;red&#39;):
        &#34;&#34;&#34;Método para graficar una vista transversal del nervio. Las fibras se muestran como puntos (sin diámetro real).

        Args:
            borde_nervio (str, optional): Color del borde del nervio. Por defecto es azul (&#39;blue&#39;).
            relleno_nervio (str, optional): Color del relleno del nervio. Por defecto no tiene color (&#39;None&#39;).
            color_fibras (str, optional): Color de las fibras, graficadas como puntos. Escribirlo según formato aceptable por Matplotlib. Por defecto es rojo (&#39;r&#39;).
        &#34;&#34;&#34;

        #Ploteo de las fibras
        matriz = self.informacion_fibras()
        plt.plot(matriz[:, 0], matriz[:, 1], label=&#39;Fibras&#39;, color=color_fibras, marker=&#39;.&#39;, linestyle=&#39;None&#39;)

        #Ploteo del nervio
        plt.gca().add_patch(
            plt.Circle((0, 0), self.radio, edgecolor=borde_nervio, facecolor=relleno_nervio, label=&#39;Nervio&#39;))

    def ploteo_fibras_circulos(self,
                               borde_nervio=&#39;blue&#39;,
                               relleno_nervio=&#39;None&#39;,
                               borde_fibras=&#39;red&#39;,
                               relleno_fibras=&#39;None&#39;):
        &#34;&#34;&#34;Método para graficar una vista transversal del nervio. Las fibras se muestran como círculos, con su respectivo diámetro.

        Args:
            borde_nervio (str, optional): Color del borde del nervio. Por defecto es azul (&#39;blue&#39;).
            relleno_nervio (str, optional): Color del relleno del nervio. Por defecto no tiene color (&#39;None&#39;).
            borde_fibras (str, optional): Color del borde de las fibras. Por defecto es rojo (&#39;red&#39;).
            relleno_fibras (str, optional): Color del relleno de las fibras. Por defecto no tiene color (&#39;None&#39;).

        Raises:
            InputError: Cuando se encuentra por lo menos una fibra con diámetro igual a 0.
        &#34;&#34;&#34;
        matriz = self.informacion_fibras()
        if matriz[:, 2].any() == 0:
            raise InputError(&#34;Por lo menos una fibra tiene diámetro igual a 0.&#34;)

        #Ploteo de las fibras
        for i in range(len(matriz)):
            circle = plt.Circle((matriz[i, 0], matriz[i, 1]),
                                matriz[i, 2],
                                edgecolor=borde_fibras,
                                facecolor=relleno_fibras,
                                label=&#34;Fibras&#34; if i == 0 else &#34;&#34;)
            plt.gca().add_patch(circle)

        #Ploteo del nervio
        plt.gca().add_patch(
            plt.Circle((0, 0), self.radio, edgecolor=borde_nervio, facecolor=relleno_nervio, label=&#39;Nervio&#39;))

    def agregar_nodos(self, distancia_nodos, variacion_nodos, desplazamiento, distribucion_variacion=&#39;uniforme&#39;):
        &#34;&#34;&#34;Método que permite agregar nodos a las fibras. 

        Args:
            distancia_nodos (float): Distancia entre nodos en las fibras en micrómetros.
            variacion (float): Variación de la distancia entre nodos en micrómetros.
            desplazamiento (float): Desplazamiento de los nodos en micrómetros. 
            distribucion_variacion (str, optional): Distribución de la variación de la distancia entre nodos. Se espera un valor correspondiente a alguna de las opciones de VariacionNodos. Por defecto es &#39;uniforme&#39;.
        &#34;&#34;&#34;
        self.distancia_nodos_promedio = distancia_nodos
        self.informacion_nodos = [
            f.ubicar_nodos(distancia_nodos=distancia_nodos,
                           variacion=variacion_nodos,
                           desplazamiento=np.random.uniform(-desplazamiento, desplazamiento),
                           distribucion_variacion=distribucion_variacion,
                           longitud_fibra=self.longitud_nervio) for f in self.fibras
        ]


class Fibra:
    &#34;&#34;&#34;Fibra.
    &#34;&#34;&#34;

    def __init__(self, x, y, diametro, velocidad):
        &#34;&#34;&#34;Método constructor de la clase Fibra.

        Args:
            x (float): Posición x del centro de la fibra. En micrómetros.
            y (float): Posición y del centro de la fibra. En micrómetros.
            diametro (float): Diámetro de la fibra. En micrómetros.
            velocidad (float): Velocidad de la fibra en [m/s].
        &#34;&#34;&#34;
        self.x = x
        self.y = y
        self.radio = diametro / 2
        self.ubicacion_nodos = []
        self.velocidad = velocidad

    def info_fibra(self, numero, pesos, electrodo):
        &#34;&#34;&#34;Método que proporciona un diccionario con información sobre la fibra.

        Args:
            numero (int): Número de fibra.
            pesos (np.ndarray): Array con los pesos de los nodos de las fibras.
            electrodo (Electrodo): Objeto de la clase Electrodo.

        Returns:
            dict: Diccionario con información de la fibra y sus nodos.
        &#34;&#34;&#34;
        datos_fibras = {
            &#34;fibra&#34;: numero,
            &#34;posicion_transversal_fibra&#34;: [self.x, self.y],
            &#34;diametro&#34;: 2 * self.radio,
            &#34;velocidad&#34;: self.velocidad,
            &#34;nodos&#34;: [{
                &#34;ubicacion&#34;: ubicacion,
                &#34;peso&#34;: pesos[i]
            } for i, ubicacion in enumerate(self.ubicacion_nodos)],
            &#34;SFAP&#34;: electrodo.sfap[numero].tolist()
        }
        return datos_fibras

    def obtener_info_fibra(self):
        &#34;&#34;&#34;Método que permite obtener información sobre la fibra, en forma de lista.

        Returns:
            list: Información sobre la fibra (posición en eje x, posición en eje y, radio de la fibra, velocidad de conducción de la fibra).
        &#34;&#34;&#34;
        return [self.x, self.y, self.radio, self.velocidad]

    def ubicar_nodos(self, longitud_fibra, distancia_nodos, variacion, desplazamiento, distribucion_variacion):
        &#34;&#34;&#34;Método para agregar nodos a una fibra.
        Args:
            longitud_fibra (float): Longitud de la fibra en micrómetros.
            distancia_nodos (float): Distancia entre nodos en las fibras en micrómetros.
            variacion (float): Variación de la distancia entre nodos en micrómetros.
            desplazamiento (float): Desplazamiento de los nodos en micrómetros. 
            distribucion_variacion (str): Distribución de la variación de la distancia entre nodos. Se espera un valor correspondiente a alguna de las opciones de VariacionNodos.

        Returns:
            numpy.ndarray: Devuelve un array con la ubicación de los nodos de la fibra.
        &#34;&#34;&#34;
        #arr = np.arange(-longitud_fibra/2,longitud_fibra*1.5 +1,distancia_nodos)
        arr = np.arange(-longitud_fibra / 2, longitud_fibra * 1.5, distancia_nodos)
        if distribucion_variacion == VariacionNodos.uniforme.name:
            var = np.random.uniform(-variacion / 2, variacion / 2, len(arr)) + desplazamiento
        elif distribucion_variacion == VariacionNodos.normal.name:
            var = np.random.normal(0, variacion, len(arr)) + desplazamiento

        ubicacion = arr + var
        ubicacion = ubicacion[(ubicacion &gt; 0) &amp; (ubicacion &lt; longitud_fibra)]
        self.ubicacion_nodos = ubicacion
        return ubicacion


class Electrodo:
    &#34;&#34;&#34;Electrodo.
    &#34;&#34;&#34;

    def __init__(self, tipo, zona_influencia, grosor=0, **kwargs):
        &#34;&#34;&#34;Método constructor de la clase Electrodo.

        Args:
            tipo (str): Tipo de electrodo. Puede ser los enumerados en el Enum TipoElectrodo.
            zona_influencia (float): Es la zona a cualquiera de los lados a la cual tiene alcance el electrodo. En micrometros.
            grosor (int, optional): Grosor del electrodo en micrometros. Por defecto es 0 micrometros. 
        
        Keyword Args:
            pos_x (float): Posición del electrodo en el eje x. En micrómetros.
            pos_y (float): Posición del electrodo en el eje y. En micrómetros.
            pos_z (float): Posición del electrodo en el eje z. En micrómetros.
            radio (float): Radio del electrodo tipo Circulo. En micrómetros.
            lista_coordenadas (list): Coordenadas en micrometros del electrodo tipo Poligono.

        Raises:
            InputError: Si el tipo de electrodo ingresado no es correcto.
            MissingParameterError: Si no se ingresan los parámetros necesarios para cada tipo de electrodo.
        &#34;&#34;&#34;

        self.tipo = tipo
        self.dist_al_electrodo = []
        self.wmax = []
        self.wlong = []
        self.pesos = []
        self.grosor = grosor
        self.zona_influencia = zona_influencia  #es la zona a izquierda o derecha que abarca el electrodo, no la zona completa
        self.valor = kwargs.get(&#39;valor&#39;, None)
        self.sfap = None
        self.cap = None

        if self.tipo == TipoElectrodo.punto.name:
            self.x = kwargs.get(&#39;pos_x&#39;)
            self.y = kwargs.get(&#39;pos_y&#39;)
            self.z = kwargs.get(&#39;pos_z&#39;)
            self.shape = Point(self.x, self.y)
            if self.x is None or self.y is None or self.z is None:
                raise MissingParameterError(
                    &#39;Los parámetros pos_x, pos_y, pos_z son necesarios para electrodo tipo Punto.&#39;)
        elif self.tipo == TipoElectrodo.circulo.name:
            self.x = kwargs.get(&#39;pos_x&#39;)
            self.y = kwargs.get(&#39;pos_y&#39;)
            self.z = kwargs.get(&#39;pos_z&#39;)
            self.radio = kwargs.get(&#39;radio&#39;)
            self.shape = Point(self.x, self.y).buffer(self.radio)
            if self.x is None or self.y is None or self.radio is None or self.z is None:
                raise MissingParameterError(
                    &#39;Los parámetros pos_x, pos_y, pos_z, radio son necesarios para el electrodo tipo Círculo.&#39;)
        elif self.tipo == TipoElectrodo.poligono.name:
            self.z = kwargs.get(&#39;pos_z&#39;)
            self.coordenadas = kwargs.get(&#39;lista_coordenadas&#39;)
            self.shape = Polygon(self.coordenadas)
            if self.z is None or self.coordenadas is None:
                raise MissingParameterError(
                    &#34;Los parámetros pos_z y lista_coordenadas son necesarios para el electrodo tipo Polígono.&#34;)
        else:
            raise InputError(&#39;El tipo de electrodo ingresado no es correcto.&#39;)

    def info_electrodo(self, idx):
        &#34;&#34;&#34;Método que genera un diccionario con información del electrodo.

        Args:
            idx (int): Ubicación del electrodo en la lista de electrodos de la clase Entorno.

        Returns:
            dict: Devuelve un diccionario con información del electrodo.
        &#34;&#34;&#34;
        return {
            &#34;electrodo_numero&#34;: idx,
            &#34;tipo&#34;: self.tipo,
            &#34;posicion_transversal_electrodo&#34;: [self.x, self.y],
            &#34;posicion_longitudinal_electrodo&#34;: self.z,
            &#34;espesor&#34;: self.grosor,
            &#34;zona_de_influencia&#34;: self.zona_influencia,
        }

    def ploteo_electrodo(self, idx):
        &#34;&#34;&#34;Método que dibuja al electrodo en el espacio.

        Args:
            idx (int): Ubicación del electrodo en la lista de electrodos de la clase Entorno.
        &#34;&#34;&#34;
        if self.tipo == TipoElectrodo.punto.name:
            x, y = self.shape.x, self.shape.y
            plt.plot(x, y, &#39;o&#39;, label=f&#34;Electrodo {idx}&#34;)
        elif self.tipo in (TipoElectrodo.circulo.name, TipoElectrodo.poligono.name):
            x, y = self.shape.exterior.xy
            plt.plot(x, y, label=f&#34;Electrodo {idx}&#34;)

    def calcular_distancias(self, lista_fibras, tipo_fibra):
        &#34;&#34;&#34;Método para calcular distancias desde el electrodo a las fibras.

        Args:
            lista_fibras (list): Lista de objetos Fibra.
            tipo_fibra (str): Consideracion de la fibra para calcular distancias. Puede ser &#39;puntual&#39; o &#39;no_puntual&#39;.
        &#34;&#34;&#34;
        if tipo_fibra == TipoFibra.puntual.name:
            self.dist_al_electrodo = np.array([self.shape.distance(Point(f.x, f.y)) for f in lista_fibras])
        elif tipo_fibra == TipoFibra.no_puntual.name:
            self.dist_al_electrodo = np.array(
                [self.shape.distance(Point(f.x, f.y).buffer(f.radio)) for f in lista_fibras])
        else:
            raise TypeError(&#34;El tipo de fibra ingresado no es correcto.&#34;)

    def calcular_wmax(self, nervio):
        &#34;&#34;&#34;Método para calcular los pesos transversales (Wmax) para cada fibra del nervio.

        Args:
            nervio (Nervio): El nervio que contiene las fibras a las cuales se les calculará el Wmax.
        &#34;&#34;&#34;
        if nervio.conductividad_transversal is not None:
            cond_transversal = nervio.conductividad_transversal * max(self.dist_al_electrodo)
        else:
            cond_transversal = nervio.porcentaje_cobertura / 100 * max(self.dist_al_electrodo)

        self.wmax = np.array(
            [1 - (x / cond_transversal) if (x &gt;= 0 and x &lt; cond_transversal) else 0 for x in self.dist_al_electrodo])

    def calcular_wlong(self, funcion, matriz_nodos):
        &#34;&#34;&#34;Método para calcular los pesos longitudinales para cada nodo de cada fibra.

        Args:
            funcion (Callable): Función con la cual se calcularán los pesos longitudinales (Wlong).
            matriz_nodos (list): Lista con la información de la ubicación de nodos de cada fibra.
        &#34;&#34;&#34;
        a = self.grosor / 2
        d = self.zona_influencia
        v = self.valor
        if funcion == funcion_constante:
            wlong = np.array(
                [np.array([funcion_constante(x=x, z=self.z, a=a, d=d, v=v) for x in lista]) for lista in matriz_nodos])
        else:
            wlong = np.array([np.array([funcion(x=x, z=self.z, a=a, d=d) for x in lista]) for lista in matriz_nodos],
                             dtype=object)
        self.wlong = wlong

    def calcular_pesos(self, nervio, funcion, matriz_nodos):
        &#34;&#34;&#34;Método que calcula los pesos en cada nodo para cada fibra del nervio.

        Args:
            nervio (Nervio): Objeto de la clase Nervio. Nervio que contiene las fibras.
            funcion (Callable): Función con la cual se calcularán los pesos longitudinales (Wlong).
            matriz_nodos (list): Lista con la ubicación de los nodos de cada fibra.
        &#34;&#34;&#34;
        self.calcular_wmax(nervio)
        self.calcular_wlong(funcion, matriz_nodos)

        self.pesos = np.array([
            np.array([wlong - (1 - wmax) if (wlong - (1 - wmax)) &gt;= 0 else 0
                      for wlong in lista_wlong])
            for wmax, lista_wlong in zip(self.wmax, self.wlong)
        ],
                              dtype=object)

    def sfap_funcion(self, frec_muestreo, velocidad_fibras, tiempo_registro, estimulo, ubicacion_nodos, num_fibras):
        &#34;&#34;&#34;Método que calcula los Potenciales de Acción de Fibra Unica para cada fibra que se encuentra en el Nervio.

        Args:
            frec_muestreo (float): Frecuencia de muestreo. En Hz.
            velocidad_fibras (float): Velocidad de conducción de una fibra. En m/s.
            tiempo_registro (float): Tiempo en el que se realiza el registro. En segundos.
            estimulo (numpy.ndarray): Array con los estímulos por fibra. 
            ubicacion_nodos (numpy.ndarray): Array con la ubicación de los nodos en todas las fibras.
            num_fibras (int): Cantidad de fibras en el nervio.
        &#34;&#34;&#34;
        total_muestras = int(tiempo_registro * frec_muestreo)
        sfap_matriz = np.zeros((len(ubicacion_nodos), total_muestras))
        for i, posiciones in enumerate(ubicacion_nodos):
            estimulo_por_nodo = array_to_multiarray(array=posiciones,
                                                    estimulo=estimulo[i],
                                                    fm=frec_muestreo,
                                                    tiempo_registro=tiempo_registro,
                                                    velocidad=velocidad_fibras[i],
                                                    peso=self.pesos[i])
            sfap = np.sum(estimulo_por_nodo, axis=0)
            sfap_matriz[i] = sfap
        self.sfap = sfap_matriz / num_fibras

    def cap_funcion(self):
        &#34;&#34;&#34;Función que calcula el Potencial de Acción Compuesto captado por el electrodo.
        &#34;&#34;&#34;
        self.cap = np.sum(self.sfap, axis=0)


class Estimulador:
    &#34;&#34;&#34;Encargado de generar el impulso de entrada al Nervio.
    &#34;&#34;&#34;

    def __init__(self, frec_muestreo, tiempo_estimulo, num_fibras):
        &#34;&#34;&#34;Método constructor de la clase Estimulador.

        Args:
            frec_muestreo (float): Frecuencia de muestreo. En Hz.
            tiempo_estimulo (float): Tiempo total que durará el registro. En segundos.
            num_fibras (int): Número de fibras del nervio.
        &#34;&#34;&#34;
        self.cant_muestras = int(frec_muestreo * tiempo_estimulo)
        self.frec = frec_muestreo
        self.tiempo_estimulo = tiempo_estimulo
        self.num_fibras = num_fibras
        self.estimulo = None
        self.vector_tiempo = np.arange(1 / self.frec, self.tiempo_estimulo + 1 / self.frec, 1 / self.frec)
        self.tipo_estimulo = None

    def crear_estimulo(self, tipo_estimulo, **kwargs):
        &#34;&#34;&#34;Método para crear el estímulo que se usará con las fibras del nervio.

        Args:
            tipo_estimulo (str): Tipo de estímulo que se creará. Se detallan en el enum TipoEstimulo.
            
        Keyword Args:
            duracion(float): Tiempo en segundos que durará la señal cuadrada.
            tiempo_inicio (float): Momento en el que inicia el estímulo. En segundos.
            lista_tiempo_inicio(list): Lista con los tiempos en segundos en los cuales se quiere tener un potencial de acción.
            frec_corte(float): Frecuencia de corte del filtro Butterworth. En Hz.
            orden_filtro(int): Orden del filtro pasa bajos.
            ubicacion_archivo(str): Ubicación del archivo csv con la señal de estimulación.
            array_estimulo(numpy.ndarray): Numpy array con la señal de estimulación.

        Raises:
            InputError: Se levanta cuando se ingresa un tipo de estímulo no válido.
        &#34;&#34;&#34;
        self.tipo_estimulo = tipo_estimulo
        if tipo_estimulo == TipoEstimulo.cuadrado.name:
            self.estimulo_cuadrado(tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0),
                                   duracion=kwargs.get(&#39;duracion&#39;, 0.0),
                                   voltaje=kwargs.get(&#39;voltaje&#39;, 1))
        elif tipo_estimulo == TipoEstimulo.potencial_de_accion.name:
            self.potencial_de_accion(tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0),
                                     frec_corte=kwargs.get(&#39;frec_corte&#39;, 1000),
                                     orden_filtro=kwargs.get(&#39;orden_filtro&#39;, 2),
                                     lista_inicio=kwargs.get(&#34;lista_inicio&#34;, None))
        elif tipo_estimulo == TipoEstimulo.manual.name:
            self.estimulo_manual(array_estimulo=kwargs.get(&#39;array_estimulo&#39;, None),
                                 tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0))
        elif tipo_estimulo == TipoEstimulo.desde_archivo.name:
            self.estimulo_desde_archivo(tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0),
                                        ubicacion_archivo=kwargs.get(&#39;ubicacion_archivo&#39;, None))
        else:
            raise InputError(&#34;El tipo de impulso ingresado no es correcto.&#34;)

    def estimulo_cuadrado(self, tiempo_inicio, duracion, voltaje):
        &#34;&#34;&#34;Método para crear un estímulo cuadrado o spike.

        Args:
            tiempo_inicio (float): Tiempo en el que se desea iniciar el estímulo. En segundos.
            duracion (float): Tiempo que durará el estímulo. Si es cero, se tendrá una spike. En segundos.
        &#34;&#34;&#34;
        inicio = int(tiempo_inicio * self.frec)
        duracion = duracion * self.frec
        self.estimulo = np.array([
            np.array([voltaje if (j &gt;= inicio and j &lt;= (inicio + duracion)) else 0
                      for j in range(self.cant_muestras)])
            for i in range(self.num_fibras)
        ])

    def potencial_de_accion(self, tiempo_inicio, lista_inicio, frec_corte, orden_filtro):
        &#34;&#34;&#34;Método para crear un potencial de acción.

        Args:
            tiempo_inicio (float): Tiempo en el que se desea iniciar el estímulo. En segundos.
            lista_tiempo_inicio (list): Lista con los tiempos (en segundos) en donde comenzará la señal.
            frec_corte (float): Frecuencia de corte del filtro pasabajos Butterworth. En Hz.
            orden_filtro (int): Orden del filtro Butterworth.
        &#34;&#34;&#34;

        if lista_inicio is not None:
            inicio = [int(i * self.frec) for i in lista_inicio]
        else:
            inicio = int(tiempo_inicio * self.frec)

        #Señal de entrada
        x = np.zeros_like(self.vector_tiempo)
        x[inicio] = 1

        #Filtro Butter
        b, a = signal.butter(orden_filtro, frec_corte / (self.frec / 2))
        Vm = signal.lfilter(b, a, x)
        Vm = Vm / np.max(Vm)  #Vm normalizado

        self.estimulo = np.repeat([Vm], self.num_fibras, axis=0)

    def estimulo_manual(self, array_estimulo, tiempo_inicio):
        &#34;&#34;&#34;Método para crear un estímulo de forma manual, a partir de un array con la señal.

        Args:
            array_estimulo (numpy.ndarray): Señal con la cual se estimularán las fibras del nervio.
            tiempo_inicio (float): Tiempo en el que inicia el estímulo. En segundos.
        &#34;&#34;&#34;
        if len(array_estimulo) != self.num_fibras:
            raise InputError(
                &#34;EL array con la señal del estímulo debe tener tantas filas como fibras haya en el nervio.&#34;)
        estim = np.zeros((len(array_estimulo), self.cant_muestras))
        inicio = int(tiempo_inicio * self.frec)
        flag = False

        if not np.isnan(sum(array_estimulo)).any() and np.issubdtype(array_estimulo.dtype, np.number):
            for i, est in enumerate(array_estimulo):
                muestras_estimulo = len(est)
                if muestras_estimulo &gt; self.cant_muestras - inicio:
                    muestras_estimulo = self.cant_muestras - inicio
                    flag = True
                estim[i][inicio:inicio + muestras_estimulo] = array_estimulo[i][:muestras_estimulo]
        if flag is True:
            print(&#34;Se recortó por lo menos una señal de estímulo debido a su tamaño.&#34;)

        estim_normalizado = estim / np.amax(estim, axis=1, keepdims=True)
        self.estimulo = estim_normalizado

    def estimulo_desde_archivo(self, ubicacion_archivo, tiempo_inicio):
        &#34;&#34;&#34;Método para cargar un estímulo desde un archivo csv.

        Args:
            ubicacion_archivo (str): Ubicación del archivo csv.
            tiempo_inicio (float): Tiempo en el que se iniciará el estímulo. En segundos.

        Raises:
            LoadingError: Error que se levanta cuando no se puede leer el archivo.
        &#34;&#34;&#34;
        try:
            estimulo = np.genfromtxt(ubicacion_archivo, delimiter=&#39;,&#39;)
        except Exception as e:
            raise LoadingError(&#39;Fallo en la carga del archivo.&#39;) from e

        self.estimulo_manual(array_estimulo=estimulo, tiempo_inicio=tiempo_inicio)


class Entorno:
    &#34;&#34;&#34;Entorno.
    &#34;&#34;&#34;

    def __init__(self, nombre=None, tiempo_registro=None):
        &#34;&#34;&#34;Metodo constructor de la clase Entorno.

        Args:
            nombre (str, optional): Nombre del experimento. Por defecto es None.
            tiempo_registro (float, optional): Tiempo en el cual se realiza el registro de la señal en segundos. Por defecto es None.
        &#34;&#34;&#34;
        self.nombre_experimento = nombre
        self.tiempo_registro = tiempo_registro
        self.nervio = None
        self.electrodos = []
        self.estimulador = None
        self.estimulo = None
        self.frec_muestreo = None
        self.cap_dif = None
        self.capdif_pos1 = None
        self.capdif_pos2 = None

    def crear_nervio(self,
                     diametro,
                     longitud,
                     num_fibras,
                     distancia_nodos,
                     diametro_fibra=None,
                     var_diametro=0,
                     conductividad_transversal=None,
                     porcentaje_cobertura=None,
                     metodo_poblacion=&#39;uniforme_con_superposicion&#39;,
                     semilla=None,
                     alfa=7.6,
                     velocidad=None,
                     variacion_nodos=0,
                     distribucion_variacion=&#39;uniforme&#39;,
                     desplazamiento=0,
                     **kwargs):
        &#34;&#34;&#34;Método para crear un nervio, poblarlo con fibras y agregar nodos a esas fibras.

        Args:
            diametro (float): Diámetro del Nervio. En micrometros.
            longitud (float): Longitud del nervio. En micrometros.
            num_fibras (int): Número de fibras con la que se quiere poblar el nervio.
            distancia_nodos (float): Distancia promedio entre nodos en las fibras. En micrometros.
            diametro_fibra (float): Diámetro de las fibras. En micrometros. Por defecto es None.
            var_diametro (float): Variación en micrometros del diámetro de las fibras con la distribución normal (Sigma). Por defecto es 0.
            conductividad_transversal (float, optional): Conductividad transversal del nervio. Por defecto es None.
            porcentaje_cobertura (float, optional): Porcentaje de alcance del electrodo en el nervio. Por defecto es None.
            metodo_poblacion (str, optional): Método con el cual se quiere poblar el nervio. Pueden ser los del enum PoblacionNervio. Por defecto es &#39;uniforme&#39;.
            semilla (int, optional): Número de la semilla para replicar la distribución. Por defecto es None.
            alfa (float, optional): Valor necesario para el cálculo de la velocidad de conducción de las fibras. En  Por defecto es 7.6. En [m/s/micrometro].
            velocidad (float,optional): Valor de la velocidad de conducción de las fibras. Se asigna a todas las fibras el mismo valor. En m/s.
            variacion (float, optional): Variación de la distancia entre nodos. En micrometros. Por defecto es 0.
            distribucion_variacion (str, optional): Forma de distribución de la variación de los nodos. Puede ser &#39;uniforme&#39; o &#39;normal&#39;. Por defecto es &#39;uniforme&#39;.
            desplazamiento (float, optional): Desplazamiento de todos los nodos en las fibras. En micrometros. Por defecto es 0. 
            
        Keyword Args:
            array_fibras (numpy.ndarray): Numpy array con 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra, en el método de población manual.
            ubicacion_archivo (str): String con la ubicación del archivo csv para el método de población desde_archivo. El archivo csv debe contener 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra.

        &#34;&#34;&#34;
        self.nervio = Nervio(
            diametro=diametro,
            longitud=longitud,
            conductividad_transversal=conductividad_transversal,
            porcentaje_cobertura=porcentaje_cobertura,
        )
        self.nervio.poblar(num_fibras=num_fibras,
                           metodo_poblacion=metodo_poblacion,
                           diametro_fibra=diametro_fibra,
                           var_diametro=var_diametro,
                           alfa=alfa,
                           velocidad=velocidad,
                           semilla=semilla,
                           **kwargs)
        self.nervio.agregar_nodos(distancia_nodos=distancia_nodos,
                                  variacion_nodos=variacion_nodos,
                                  distribucion_variacion=distribucion_variacion,
                                  desplazamiento=desplazamiento)

    def crear_electrodo(self, tipo, zona_influencia, grosor=0, funcion=funcion_trapecio, **kwargs):
        &#34;&#34;&#34;Método para crear un electrodo en el entorno de medición.

        Args:
            tipo (str): Tipo de electrodo. Puede ser los enumerados en el Enum TipoElectrodo.
            zona_influencia (float): Es la zona a cualquiera de los lados a la cual tiene alcance el electrodo. En micrometros.
            grosor (int, optional): Grosor del electrodo en micrometros. Por defecto es 0.
            funcion (Callable, optional): Función con la cual se calcularán los pesos para cada nodo. Por defecto se usa la &#39;funcion_trapecio&#39;.
        
        Keyword Args:
            pos_x (float): Posición del electrodo en el eje x. En micrómetros.
            pos_y (float): Posición del electrodo en el eje y. En micrómetros.
            pos_z (float): Posición del electrodo en el eje z. En micrómetros.
            radio (float): Radio del electrodo tipo Circulo. En micrómetros.
            lista_coordenadas (list): Coordenadas en micrometros del electrodo tipo Poligono.

        Raises:
            ObjectCreationError: Se levanta el error cuando se quiere crear un Electrodo antes de crear un Nervio.
        &#34;&#34;&#34;
        if self.nervio is None:
            raise ObjectCreationError(&#34;Se debe crear un nervio antes de crear un electrodo.&#34;)
        nuevo_electrodo = Electrodo(tipo=tipo, zona_influencia=zona_influencia, grosor=grosor, **kwargs)
        nuevo_electrodo.calcular_distancias(lista_fibras=self.nervio.fibras,
                                            tipo_fibra=kwargs.get(&#39;tipo_fibra&#39;, &#39;puntual&#39;))
        nuevo_electrodo.calcular_pesos(nervio=self.nervio, funcion=funcion, matriz_nodos=self.nervio.informacion_nodos)
        self.electrodos.append(nuevo_electrodo)

    def crear_estimulo(self, tipo_estimulo, frec_muestreo, tiempo_estimulo, **kwargs):
        &#34;&#34;&#34;Método que permite crear el estímulo con el que se excitará el nervio.

        Args:
            tipo_estimulo (str): Tipo de estímulo que se creará. Se detallan en el enum TipoEstimulo. En segundos.
            frec_muestreo (float): Frecuencia de muestreo de la señal. En Hz.
            tiempo_estimulo (float): Tiempo total en el que se realizará la medición. En segundos.
        
        Keyword Args:
            duracion(float): Tiempo en segundos que durará la señal cuadrada. En segundos.
            frec_corte(float): Frecuencia de corte del filtro Butterworth. En Hz.
            orden_filtro(int): Orden del filtro pasa bajos.
            ubicacion_archivo(str): Ubicación del archivo csv con la señal de estimulación.
            array_estimulo(numpy.ndarray): Numpy array con la señal de estimulación para cada fibra.
            tiempo_inicio (float): Momento en el que inicia el estímulo. En segundos.
            lista_inicio (list): Lista con los tiempos de inicio para el tren de señales. En segundos.
            voltaje (float): Voltaje del estímulo. En voltios. Por defecto es 1[V].
        &#34;&#34;&#34;
        self.estimulador = Estimulador(frec_muestreo=frec_muestreo,
                                       tiempo_estimulo=tiempo_estimulo,
                                       num_fibras=self.nervio.cantidad_fibras)
        self.estimulador.crear_estimulo(tipo_estimulo=tipo_estimulo, **kwargs)
        self.estimulo = self.estimulador.estimulo
        self.frec_muestreo = frec_muestreo

        if self.tiempo_registro is None:
            self.tiempo_registro = tiempo_estimulo * 1.5

    def cap(self):
        &#34;&#34;&#34;Método con el cual se obtiene los Potenciales de Acción Compuestos por cada electrodo que se encuentra en el entorno.
        &#34;&#34;&#34;
        for electrodo in self.electrodos:
            electrodo.sfap_funcion(frec_muestreo=self.frec_muestreo,
                                   velocidad_fibras=self.nervio.informacion_fibras()[:, 3],
                                   tiempo_registro=self.tiempo_registro,
                                   estimulo=self.estimulo,
                                   ubicacion_nodos=self.nervio.informacion_nodos,
                                   num_fibras=self.nervio.cantidad_fibras)
            electrodo.cap_funcion()

    def cap_diferencial(self, posicion_1=0, posicion_2=1):
        &#34;&#34;&#34;Método que calcula el Potencial de Accion Diferencial entre dos electrodos.

        Args:
            posicion_1 (int): Posicion del primer electrodo.
            posicion_2 (int): Posicion del segundo electrodo.
        &#34;&#34;&#34;
        self.cap_dif = self.electrodos[posicion_1].cap - self.electrodos[posicion_2].cap
        self.capdif_pos1 = posicion_1
        self.capdif_pos2 = posicion_2

    def informacion_json(self):
        &#34;&#34;&#34;Método que devuelve un archivo JSON con información sobre el nervio, las fibras y los electrodos.
        &#34;&#34;&#34;
        data = {}
        for idx, electrodo in enumerate(self.electrodos):
            data[idx] = {
                &#34;Electrodo&#34;: electrodo.info_electrodo(idx=idx),
                &#34;Nervio&#34;: self.nervio.info_nervio(),
                &#34;Fibras&#34;: [
                    fibra.info_fibra(numero=x, pesos=electrodo.pesos[x], electrodo=electrodo)
                    for x, fibra in enumerate(self.nervio.fibras)
                ],
                &#34;CAP&#34;: electrodo.cap.tolist()
            }
        with open(&#39;data.json&#39;, &#39;w&#39;) as file:
            json.dump(data, file, indent=3)

        del data

    def informe_experimento(self, guardar=False, nombre_archivo=&#34;informe.txt&#34;):
        &#34;&#34;&#34;Método que brinda un informe rápido sobre variables del nervio, electrodos y estimulador. Brinda la posibilidad de guardar la información en un archivo txt.

        Args:
            guardar (bool, optional): Variable que indica si se quiere guardar la información en un archivo txt. Por defecto es False.
        &#34;&#34;&#34;
        ubicaciones_electrodos = [[e.x, e.y, e.z] for e in self.electrodos]
        tipos_electrodos = [e.tipo for e in self.electrodos]
        grosor = [e.grosor for e in self.electrodos]
        zonas = [e.zona_influencia for e in self.electrodos]
        texto = f&#39;&#39;&#39;
NOMBRE DEL EXPERIMENTO: {self.nombre_experimento}

Datos del nervio:
        * Diametro: {2*self.nervio.radio} micrometros
        * Longitud: {self.nervio.longitud_nervio} micrometros
        * Cantidad de fibras: {self.nervio.cantidad_fibras}
        * Posicion del centro del nervio: [{self.nervio.centro_nervio_x},{self.nervio.centro_nervio_y}]
        * Conductividad transversal: {self.nervio.conductividad_transversal}
        * Porcentaje de cobertura del electrodo: {self.nervio.porcentaje_cobertura}
        * Metodo de poblacion: {self.nervio.metodo_poblacion}
        * Distancia entre nodos promedio: {self.nervio.distancia_nodos_promedio}
        
Datos de los electrodos:
        * Cantidad de electrodos: {len(self.electrodos)}
        * Ubicacion de electrodos: {ubicaciones_electrodos}
        * Tipos de electrodos: {tipos_electrodos}
        * Grosor electrodos: {grosor}
        * Zonas de influencia: {zonas}
        
Datos del estimulador:
        * Tipo de estimulo: {self.estimulador.tipo_estimulo}
        * Frecuencia de muestreo: {self.frec_muestreo} Hz
        * Tiempo de estimulo: {self.estimulador.tiempo_estimulo} segundos
        * Tiempo de registro : {self.tiempo_registro} segundos
        &#39;&#39;&#39;
        print(texto)
        if guardar is True:
            with open(nombre_archivo, &#34;w&#34;) as file:
                file.write(texto)

    def archivo_matlab(self, nombre=&#34;info_matlab.mat&#34;):
        &#34;&#34;&#34;Devuelve un archivo .mat para ser usado en Matlab. Incluye información sobre el CAP diferencial, los CAPs con los cuales se calculó el CAP diferencial, el estímulo, y los vectores de tiempo del estímulo y CAPs.

        Args:
            nombre (str): Nombre del archivo .mat
        &#34;&#34;&#34;

        info = {
            &#39;CAPdif&#39;:
                self.cap_dif,
            &#39;CAP1&#39;:
                self.electrodos[self.capdif_pos1].cap,
            &#39;CAP2&#39;:
                self.electrodos[self.capdif_pos2].cap,
            &#39;Vm&#39;:
                self.estimulador.estimulo[0],
            &#39;t_vm&#39;:
                self.estimulador.vector_tiempo,
            &#39;t_cap&#39;:
                np.arange(1 / self.frec_muestreo, 1 / self.frec_muestreo + self.tiempo_registro, 1 / self.frec_muestreo)
        }
        savemat(nombre, info)
        del info

    def quitar_electrodo(self, posicion):
        &#34;&#34;&#34;Método para quitar un electrodo.

        Args:
            posicion (int): Posición del electrodo que se quiere quitar.
        &#34;&#34;&#34;
        del self.electrodos[posicion]

    def dibujar_entorno(self,
                        forma_ploteo=&#39;fibras_sin_diametro&#39;,
                        titulo=&#39;Entorno&#39;,
                        xlabel=&#39;x (μm)&#39;,
                        ylabel=&#39;y (μm)&#39;,
                        borde_nervio=&#39;blue&#39;,
                        relleno_nervio=&#39;None&#39;,
                        guardar=False,
                        nombre_figura=&#34;figura.png&#34;,
                        **kwargs):
        &#34;&#34;&#34;Método para dibujar el entorno de trabajo (nervio, fibras y electrodos).
        Args:
            forma_ploteo (str, optional): Se puede dibujar las fibras con diámetro (fibras_con_diametro) o como fibras puntuales (fibras_sin_diametro). Por defecto es &#39;fibras_sin_diametro&#39;.
            titulo (str, optional): Título de la imagen. Por defecto es &#39;Entorno&#39;.
            xlabel (str, optional): Etiqueta en eje x. Por defecto es &#39;x (μm)&#39;.
            ylabel (str, optional): Etiqueta en eje y. Por defecto es &#39;y (μm)&#39;.
            borde_nervio (str, optional): Color del borde del nervio. Por defecto es &#39;blue&#39;.
            relleno_nervio (str, optional): Color del relleno del nervio. Por defecto es &#39;None&#39;.
            guardar (bool): Parámetro que indica si la imagen se guardará (True) o no (False). Por defecto es False.
            nombre_figura (str): Nombre que se le dará a la figura que se desea guardar. Por defecto es &#34;figura.png&#34;.
        
        Kwargs:
            borde_fibras (str): Color del borde de las fibras. Se aplica cuando FormaDePloteo es &#39;fibras_con_diametro&#39;. Por defecto es &#39;blue&#39;.
            relleno_fibras (str): Color del relleno de las fibras. Se aplica cuando FormaDePloteo es &#39;fibras_con_diametro&#39;. Por defecto es &#39;None&#39;.
            color_fibras (str): Color de las fibras. Se aplica cuando FormaDePloteo es &#39;fibras_sin_diametro&#39;. Por defecto es &#39;red&#39;.

        Raises:
            InputError: Error al introducir una forma de ploteo incorrecta.
        &#34;&#34;&#34;

        fig = plt.figure()

        #Ploteo nervio y fibras
        if forma_ploteo == FormaDePloteo.fibras_sin_diametro.name:
            self.nervio.ploteo_fibras_puntos(borde_nervio=borde_nervio,
                                             relleno_nervio=relleno_nervio,
                                             color_fibras=kwargs.get(&#39;color_fibras&#39;, &#39;red&#39;))
        elif forma_ploteo == FormaDePloteo.fibras_con_diametro.name:
            self.nervio.ploteo_fibras_circulos(borde_nervio=borde_nervio,
                                               relleno_nervio=relleno_nervio,
                                               borde_fibras=kwargs.get(&#39;borde_fibras&#39;, &#39;red&#39;),
                                               relleno_fibras=kwargs.get(&#39;relleno_fibras&#39;, &#39;None&#39;))
        else:
            raise InputError(
                &#39;Ingrese una forma de ploteo correcta. Puede ser \&#39;fibras_con_diametro\&#39; o \&#39;fibras_sin_diametro\&#39; &#39;)

        #Ploteo electrodos
        for idx, electrodo in enumerate(self.electrodos):
            electrodo.ploteo_electrodo(idx=idx)

        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.title(titulo)
        plt.legend(fontsize=&#39;xx-small&#39;)
        plt.axis(&#39;equal&#39;)
        plt.show()

        if guardar is True:
            fig.savefig(nombre_figura, dpi=300, format=&#34;png&#34;)

    def graficas(self, titulo=None, guardar=False, nombre_figura=&#34;figura.png&#34;):
        &#34;&#34;&#34;Método que permite graficar el estímulo, CAP de cada electrodo que se tenga agregado y CAP diferencial de 2 de los electrodos con los cuales se lo obtuvo.

        Args:
            titulo (str, optional): Título del gráfico. Por defecto no hay.
            guardar (bool, optional): Variable que indica si se quiere guardar el dibujo como imagen tipo PNG. Por defecto es False.
            nombre_figura (str, optional): Nombre con el cual se quiere guardar la imagen. Por defecto es &#34;figura.png&#34;.
        &#34;&#34;&#34;
        fig = plt.figure()

        #Vector tiempo
        vector_tiempo = np.arange(1 / self.frec_muestreo, 1 / self.frec_muestreo + self.tiempo_registro,
                                  1 / self.frec_muestreo)

        #CAP
        for idx, electrodo in enumerate(self.electrodos):
            plt.plot(vector_tiempo * 1000, electrodo.cap, label=f&#34;CAP Electrodo n°{idx}&#34;)

        #CAP diferencial
        plt.plot(vector_tiempo * 1000,
                 self.cap_dif,
                 label=f&#34;CAP diferencial electrodos {self.capdif_pos1}-{self.capdif_pos2}&#34;)

        #Vm
        plt.plot(self.estimulador.vector_tiempo * 1000,
                 self.estimulador.estimulo[0],
                 label=&#34;Vm&#34;,
                 color=&#39;gray&#39;,
                 linewidth=0.7)

        plt.title(titulo)
        plt.xlabel(&#39;Tiempo (ms)&#39;)
        plt.ylabel(&#39;Amplitud relativa&#39;)
        plt.legend(fontsize=&#39;small&#39;)
        plt.show()

        if guardar is True:
            fig.savefig(nombre_figura, dpi=300, format=&#34;png&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="simulacion.array_to_multiarray"><code class="name flex">
<span>def <span class="ident">array_to_multiarray</span></span>(<span>array, estimulo, fm, tiempo_registro, velocidad, peso)</span>
</code></dt>
<dd>
<div class="desc"><p>Función que, dado un array con posiciones, crea un array de arrays, con estímulos desplazados para cada posición.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array que contiene las posiciones con las cuales se hará el desplazamiento del estímulo.</dd>
<dt><strong><code>estimulo</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Señal que es desplazada.</dd>
<dt><strong><code>fm</code></strong> :&ensp;<code>float</code></dt>
<dd>Frecuencia de muestreo. En Hz.</dd>
<dt><strong><code>tiempo_registro</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo total en el que se hará el registro. En segundos.</dd>
<dt><strong><code>velocidad</code></strong> :&ensp;<code>float</code></dt>
<dd>Velocidad a la cual se desplaza la señal. En m/s.</dd>
<dt><strong><code>peso</code></strong> :&ensp;<code>float</code></dt>
<dd>Factor por el cual se multiplica la señal. </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Devuelve el array de arrays con los estímulos desplazados.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def array_to_multiarray(array, estimulo, fm, tiempo_registro, velocidad, peso):
    &#34;&#34;&#34;Función que, dado un array con posiciones, crea un array de arrays, con estímulos desplazados para cada posición.

    Args:
        array (numpy.ndarray): Array que contiene las posiciones con las cuales se hará el desplazamiento del estímulo.
        estimulo (numpy.ndarray): Señal que es desplazada.
        fm (float): Frecuencia de muestreo. En Hz.
        tiempo_registro (float): Tiempo total en el que se hará el registro. En segundos.
        velocidad (float): Velocidad a la cual se desplaza la señal. En m/s.
        peso (float): Factor por el cual se multiplica la señal. 

    Returns:
        numpy.ndarray: Devuelve el array de arrays con los estímulos desplazados.
    &#34;&#34;&#34;
    total_muestras = int(tiempo_registro * fm)
    multiarray = np.zeros((len(array), total_muestras))
    for i, posicion in enumerate(array):
        vector = insertar_estimulo(estimulo=estimulo,
                                   posicion=posicion,
                                   fm=fm,
                                   tiempo_registro=tiempo_registro,
                                   velocidad=velocidad,
                                   peso=peso[i])
        if vector is not None:
            multiarray[i] = vector
    return multiarray</code></pre>
</details>
</dd>
<dt id="simulacion.distancia_entre_circulos"><code class="name flex">
<span>def <span class="ident">distancia_entre_circulos</span></span>(<span>x1, y1, radio1, x2, y2, radio2)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que devuelve la distancia entre dos círculos.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordenada x del centro del primer círculo.</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordenada y del centro del primer círculo.</dd>
<dt><strong><code>radio1</code></strong> :&ensp;<code>float</code></dt>
<dd>Radio del primer círculo.</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordenada x del centro del segundo círculo.</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordenada y del centro del segundo círculo.</dd>
<dt><strong><code>radio2</code></strong> :&ensp;<code>float</code></dt>
<dd>Radio del segundo círculo.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Devuelve el cálculo de la distancia entre los dos círculos.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distancia_entre_circulos(x1, y1, radio1, x2, y2, radio2):
    &#34;&#34;&#34;Método que devuelve la distancia entre dos círculos.

    Args:
        x1 (float): Coordenada x del centro del primer círculo.
        y1 (float): Coordenada y del centro del primer círculo.
        radio1 (float): Radio del primer círculo.
        x2 (float): Coordenada x del centro del segundo círculo.
        y2 (float): Coordenada y del centro del segundo círculo.
        radio2 (float): Radio del segundo círculo.

    Returns:
        float: Devuelve el cálculo de la distancia entre los dos círculos.
    &#34;&#34;&#34;
    return (distancia_entre_puntos(x1=x1, y1=y1, x2=x2, y2=y2)) - radio1 - radio2</code></pre>
</details>
</dd>
<dt id="simulacion.distancia_entre_puntos"><code class="name flex">
<span>def <span class="ident">distancia_entre_puntos</span></span>(<span>x1, y1, x2, y2)</span>
</code></dt>
<dd>
<div class="desc"><p>Función que mide la distancia entre dos puntos.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordenada x del primer punto. </dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordenada y del primer punto.</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordenada x del segundo punto.</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordenada y del segundo punto.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>La función devuelve la distancia entre los dos puntos.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distancia_entre_puntos(x1, y1, x2, y2):
    &#34;&#34;&#34;Función que mide la distancia entre dos puntos.

    Args:
        x1 (float): Coordenada x del primer punto. 
        y1 (float): Coordenada y del primer punto.
        x2 (float): Coordenada x del segundo punto.
        y2 (float): Coordenada y del segundo punto.

    Returns:
        float: La función devuelve la distancia entre los dos puntos.
    &#34;&#34;&#34;
    return np.sqrt((x1 - x2)**2 + (y1 - y2)**2)</code></pre>
</details>
</dd>
<dt id="simulacion.funcion_constante"><code class="name flex">
<span>def <span class="ident">funcion_constante</span></span>(<span>x, z, d, a, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Función que devuelve un valor constante en un cierto rango.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Valor en el cual se evaluará la función.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>Centro del intervalo.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>Valor del ancho del intervalo, hacia izquierda o derecha.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>Extensión para el ancho del intervalo, hacia izquierda o derecha.</dd>
<dt><strong><code>valor</code></strong> :&ensp;<code>float</code></dt>
<dd>El valor de la función cuando no es cero.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Devuelve el valor de la función evaluado en un dado x.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcion_constante(x, z, d, a, v):
    &#34;&#34;&#34;Función que devuelve un valor constante en un cierto rango.

    Args:
        x (float): Valor en el cual se evaluará la función.
        z (float): Centro del intervalo.
        d (float): Valor del ancho del intervalo, hacia izquierda o derecha.
        a (float): Extensión para el ancho del intervalo, hacia izquierda o derecha.
        valor (float): El valor de la función cuando no es cero.

    Returns:
        float: Devuelve el valor de la función evaluado en un dado x.
    &#34;&#34;&#34;
    if x &gt;= z - d - a and x &lt;= z + d + a:
        return v

    return 0</code></pre>
</details>
</dd>
<dt id="simulacion.funcion_gaussiana"><code class="name flex">
<span>def <span class="ident">funcion_gaussiana</span></span>(<span>x, z, d, a)</span>
</code></dt>
<dd>
<div class="desc"><p>Función exponencial con caída como una función gaussiana. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Valor en el cual se evaluará la función.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>mu, esperanza de la función gaussiana.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>Valor hasta el cual se quiere lograr la caída de la función.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>Valor hasta el cual se quiere mantener la función igual a 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Devuelve el valor de la función evaluado en un dado x.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcion_gaussiana(x, z, d, a):
    &#34;&#34;&#34;Función exponencial con caída como una función gaussiana. 

    Args:
        x (float): Valor en el cual se evaluará la función.
        z (float): mu, esperanza de la función gaussiana.
        d (float): Valor hasta el cual se quiere lograr la caída de la función.
        a (float): Valor hasta el cual se quiere mantener la función igual a 1.

    Returns:
        float: Devuelve el valor de la función evaluado en un dado x.
    &#34;&#34;&#34;
    if (x &gt; z - d - a and x &lt; z - a):
        exponente = -(x - (z - a))**2 / (2 * (d / 3)**2)
        return np.exp(exponente)
    if (x &gt; z + a and x &lt; z + a + d):
        exponente = -(x - (z + a))**2 / (2 * (d / 3)**2)
        return np.exp(exponente)
    if (x &gt;= z - a and x &lt;= z + a):
        return 1
    return 0</code></pre>
</details>
</dd>
<dt id="simulacion.funcion_trapecio"><code class="name flex">
<span>def <span class="ident">funcion_trapecio</span></span>(<span>x, z, d, a)</span>
</code></dt>
<dd>
<div class="desc"><p>Función trapecio. Devuelve el valor de la función trapecio para un dado x.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Valor en el cual se evaluará la función trapecio.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>Centro simétrico del trapecio.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>La mitad del valor del largo inferior del trapecio.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>La mitad del largo superior del trapecio.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Devuelve el valor de la función evaluado en un dado x.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcion_trapecio(x, z, d, a):
    &#34;&#34;&#34;Función trapecio. Devuelve el valor de la función trapecio para un dado x.

    Args:
        x (float): Valor en el cual se evaluará la función trapecio.
        z (float): Centro simétrico del trapecio.
        d (float): La mitad del valor del largo inferior del trapecio.
        a (float): La mitad del largo superior del trapecio.

    Returns:
        float: Devuelve el valor de la función evaluado en un dado x.
    &#34;&#34;&#34;
    if (x &gt; z - d - a and x &lt; z - a):
        return (x - z + d + a) / d
    if (x &gt; z + a and x &lt; z + a + d):
        return (z + a + d - x) / d
    if (x &gt;= z - a and x &lt;= z + a):
        return 1
    return 0</code></pre>
</details>
</dd>
<dt id="simulacion.insertar_estimulo"><code class="name flex">
<span>def <span class="ident">insertar_estimulo</span></span>(<span>estimulo, posicion, fm, tiempo_registro, velocidad, peso)</span>
</code></dt>
<dd>
<div class="desc"><p>Función que desplaza un numpy array dada una posición de inicio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>estimulo</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Señal que es desplazada.</dd>
<dt><strong><code>posicion</code></strong> :&ensp;<code>float</code></dt>
<dd>Posición hasta la que se desplaza el inicio del estímulo. En micrometros.</dd>
<dt><strong><code>fm</code></strong> :&ensp;<code>float</code></dt>
<dd>Frecuencia de muestreo de la señal. En Hz.</dd>
<dt><strong><code>tiempo_registro</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo total en el que se hará el registro. En segundos.</dd>
<dt><strong><code>velocidad</code></strong> :&ensp;<code>float</code></dt>
<dd>Velocidad a la cual se desplaza la señal. En m/s.</dd>
<dt><strong><code>peso</code></strong> :&ensp;<code>float</code></dt>
<dd>Factor por el cual se multiplica la señal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Devuelve el estímulo desplazado, en el tiempo de registro.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertar_estimulo(estimulo, posicion, fm, tiempo_registro, velocidad, peso):
    &#34;&#34;&#34;Función que desplaza un numpy array dada una posición de inicio.

    Args:
        estimulo (numpy.ndarray): Señal que es desplazada.
        posicion (float): Posición hasta la que se desplaza el inicio del estímulo. En micrometros.
        fm (float): Frecuencia de muestreo de la señal. En Hz.
        tiempo_registro (float): Tiempo total en el que se hará el registro. En segundos.
        velocidad (float): Velocidad a la cual se desplaza la señal. En m/s.
        peso (float): Factor por el cual se multiplica la señal.

    Returns:
        numpy.ndarray: Devuelve el estímulo desplazado, en el tiempo de registro.
    &#34;&#34;&#34;
    total_muestras = int(tiempo_registro * fm)
    muestras_estimulo = len(estimulo)
    vector = np.zeros(total_muestras)
    inicio = int((posicion * fm) / (velocidad * 1000000))  #retardo

    if inicio &lt; total_muestras and peso != 0:
        if muestras_estimulo &gt; (total_muestras - inicio):
            muestras_estimulo = total_muestras - inicio
        vector[inicio:inicio + muestras_estimulo] = estimulo[0:muestras_estimulo] * peso
        return vector

    return None</code></pre>
</details>
</dd>
<dt id="simulacion.is_inside_circencirc"><code class="name flex">
<span>def <span class="ident">is_inside_circencirc</span></span>(<span>r1, x1, y1, r0, x0, y0)</span>
</code></dt>
<dd>
<div class="desc"><p>Función con la que se evalúa si un primer círculo (x1,y1,r1) se encuentra dentro de un segundo círculo (x0,y0,r0).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r1</code></strong> :&ensp;<code>float</code></dt>
<dd>Radio del primer círculo.</dd>
<dt><strong><code>x1</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordenada x del centro del primer círculo.</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordenada y del centro del primer círculo.</dd>
<dt><strong><code>r0</code></strong> :&ensp;<code>float</code></dt>
<dd>Radio del círculo al que se le evalúa si contiene al primer círculo.</dd>
<dt><strong><code>x0</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Coordenada x del centro del círculo al que se le evalúa si contiene al primer círculo. Por defecto es 0.</dd>
<dt><strong><code>y0</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Coordenada y del centro del círculo al que se le evalúa si contiene al primer círculo. Por defecto es 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Devuelve True o False de acuerdo a si el primer círculo está contenido dentro del segundo o no.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_inside_circencirc(r1, x1, y1, r0, x0, y0):
    &#34;&#34;&#34;Función con la que se evalúa si un primer círculo (x1,y1,r1) se encuentra dentro de un segundo círculo (x0,y0,r0).

    Args:
        r1 (float): Radio del primer círculo.
        x1 (float): Coordenada x del centro del primer círculo.
        y1 (float): Coordenada y del centro del primer círculo.
        r0 (float): Radio del círculo al que se le evalúa si contiene al primer círculo.
        x0 (float, optional): Coordenada x del centro del círculo al que se le evalúa si contiene al primer círculo. Por defecto es 0.
        y0 (float, optional): Coordenada y del centro del círculo al que se le evalúa si contiene al primer círculo. Por defecto es 0.

    Returns:
        bool: Devuelve True o False de acuerdo a si el primer círculo está contenido dentro del segundo o no.
    &#34;&#34;&#34;
    return r0 &gt;= r1 + distancia_entre_puntos(x1=x1, y1=y1, x2=x0, y2=y0)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="simulacion.Electrodo"><code class="flex name class">
<span>class <span class="ident">Electrodo</span></span>
<span>(</span><span>tipo, zona_influencia, grosor=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Electrodo.</p>
<p>Método constructor de la clase Electrodo.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tipo</code></strong> :&ensp;<code>str</code></dt>
<dd>Tipo de electrodo. Puede ser los enumerados en el Enum TipoElectrodo.</dd>
<dt><strong><code>zona_influencia</code></strong> :&ensp;<code>float</code></dt>
<dd>Es la zona a cualquiera de los lados a la cual tiene alcance el electrodo. En micrometros.</dd>
<dt><strong><code>grosor</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Grosor del electrodo en micrometros. Por defecto es 0 micrometros. </dd>
</dl>

<h2 id="args">Keyword Args</h2>
<dl>
<dt><strong><code>pos_x</code></strong> :&ensp;<code>float</code></dt>
<dd>Posición del electrodo en el eje x. En micrómetros.</dd>
<dt><strong><code>pos_y</code></strong> :&ensp;<code>float</code></dt>
<dd>Posición del electrodo en el eje y. En micrómetros.</dd>
<dt><strong><code>pos_z</code></strong> :&ensp;<code>float</code></dt>
<dd>Posición del electrodo en el eje z. En micrómetros.</dd>
<dt><strong><code>radio</code></strong> :&ensp;<code>float</code></dt>
<dd>Radio del electrodo tipo Circulo. En micrómetros.</dd>
<dt><strong><code>lista_coordenadas</code></strong> :&ensp;<code>list</code></dt>
<dd>Coordenadas en micrómetros del electrodo tipo Poligono.</dd>
</dl>

<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="simulacion.InputError" href="#simulacion.InputError">InputError</a></code></dt>
<dd>Si el tipo de electrodo ingresado no es correcto.</dd>
<dt><code><a title="simulacion.MissingParameterError" href="#simulacion.MissingParameterError">MissingParameterError</a></code></dt>
<dd>Si no se ingresan los parámetros necesarios para cada tipo de electrodo.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Electrodo:
    &#34;&#34;&#34;Electrodo.
    &#34;&#34;&#34;

    def __init__(self, tipo, zona_influencia, grosor=0, **kwargs):
        &#34;&#34;&#34;Método constructor de la clase Electrodo.

        Args:
            tipo (str): Tipo de electrodo. Puede ser los enumerados en el Enum TipoElectrodo.
            zona_influencia (float): Es la zona a cualquiera de los lados a la cual tiene alcance el electrodo. En micrometros.
            grosor (int, optional): Grosor del electrodo en micrometros. Por defecto es 0 micrometros. 
        
        Keyword Args:
            pos_x (float): Posición del electrodo en el eje x. En micrómetros.
            pos_y (float): Posición del electrodo en el eje y. En micrómetros.
            pos_z (float): Posición del electrodo en el eje z. En micrómetros.
            radio (float): Radio del electrodo tipo Circulo. En micrómetros.
            lista_coordenadas (list): Coordenadas en micrometros del electrodo tipo Poligono.

        Raises:
            InputError: Si el tipo de electrodo ingresado no es correcto.
            MissingParameterError: Si no se ingresan los parámetros necesarios para cada tipo de electrodo.
        &#34;&#34;&#34;

        self.tipo = tipo
        self.dist_al_electrodo = []
        self.wmax = []
        self.wlong = []
        self.pesos = []
        self.grosor = grosor
        self.zona_influencia = zona_influencia  #es la zona a izquierda o derecha que abarca el electrodo, no la zona completa
        self.valor = kwargs.get(&#39;valor&#39;, None)
        self.sfap = None
        self.cap = None

        if self.tipo == TipoElectrodo.punto.name:
            self.x = kwargs.get(&#39;pos_x&#39;)
            self.y = kwargs.get(&#39;pos_y&#39;)
            self.z = kwargs.get(&#39;pos_z&#39;)
            self.shape = Point(self.x, self.y)
            if self.x is None or self.y is None or self.z is None:
                raise MissingParameterError(
                    &#39;Los parámetros pos_x, pos_y, pos_z son necesarios para electrodo tipo Punto.&#39;)
        elif self.tipo == TipoElectrodo.circulo.name:
            self.x = kwargs.get(&#39;pos_x&#39;)
            self.y = kwargs.get(&#39;pos_y&#39;)
            self.z = kwargs.get(&#39;pos_z&#39;)
            self.radio = kwargs.get(&#39;radio&#39;)
            self.shape = Point(self.x, self.y).buffer(self.radio)
            if self.x is None or self.y is None or self.radio is None or self.z is None:
                raise MissingParameterError(
                    &#39;Los parámetros pos_x, pos_y, pos_z, radio son necesarios para el electrodo tipo Círculo.&#39;)
        elif self.tipo == TipoElectrodo.poligono.name:
            self.z = kwargs.get(&#39;pos_z&#39;)
            self.coordenadas = kwargs.get(&#39;lista_coordenadas&#39;)
            self.shape = Polygon(self.coordenadas)
            if self.z is None or self.coordenadas is None:
                raise MissingParameterError(
                    &#34;Los parámetros pos_z y lista_coordenadas son necesarios para el electrodo tipo Polígono.&#34;)
        else:
            raise InputError(&#39;El tipo de electrodo ingresado no es correcto.&#39;)

    def info_electrodo(self, idx):
        &#34;&#34;&#34;Método que genera un diccionario con información del electrodo.

        Args:
            idx (int): Ubicación del electrodo en la lista de electrodos de la clase Entorno.

        Returns:
            dict: Devuelve un diccionario con información del electrodo.
        &#34;&#34;&#34;
        return {
            &#34;electrodo_numero&#34;: idx,
            &#34;tipo&#34;: self.tipo,
            &#34;posicion_transversal_electrodo&#34;: [self.x, self.y],
            &#34;posicion_longitudinal_electrodo&#34;: self.z,
            &#34;espesor&#34;: self.grosor,
            &#34;zona_de_influencia&#34;: self.zona_influencia,
        }

    def ploteo_electrodo(self, idx):
        &#34;&#34;&#34;Método que dibuja al electrodo en el espacio.

        Args:
            idx (int): Ubicación del electrodo en la lista de electrodos de la clase Entorno.
        &#34;&#34;&#34;
        if self.tipo == TipoElectrodo.punto.name:
            x, y = self.shape.x, self.shape.y
            plt.plot(x, y, &#39;o&#39;, label=f&#34;Electrodo {idx}&#34;)
        elif self.tipo in (TipoElectrodo.circulo.name, TipoElectrodo.poligono.name):
            x, y = self.shape.exterior.xy
            plt.plot(x, y, label=f&#34;Electrodo {idx}&#34;)

    def calcular_distancias(self, lista_fibras, tipo_fibra):
        &#34;&#34;&#34;Método para calcular distancias desde el electrodo a las fibras.

        Args:
            lista_fibras (list): Lista de objetos Fibra.
            tipo_fibra (str): Consideracion de la fibra para calcular distancias. Puede ser &#39;puntual&#39; o &#39;no_puntual&#39;.
        &#34;&#34;&#34;
        if tipo_fibra == TipoFibra.puntual.name:
            self.dist_al_electrodo = np.array([self.shape.distance(Point(f.x, f.y)) for f in lista_fibras])
        elif tipo_fibra == TipoFibra.no_puntual.name:
            self.dist_al_electrodo = np.array(
                [self.shape.distance(Point(f.x, f.y).buffer(f.radio)) for f in lista_fibras])
        else:
            raise TypeError(&#34;El tipo de fibra ingresado no es correcto.&#34;)

    def calcular_wmax(self, nervio):
        &#34;&#34;&#34;Método para calcular los pesos transversales (Wmax) para cada fibra del nervio.

        Args:
            nervio (Nervio): El nervio que contiene las fibras a las cuales se les calculará el Wmax.
        &#34;&#34;&#34;
        if nervio.conductividad_transversal is not None:
            cond_transversal = nervio.conductividad_transversal * max(self.dist_al_electrodo)
        else:
            cond_transversal = nervio.porcentaje_cobertura / 100 * max(self.dist_al_electrodo)

        self.wmax = np.array(
            [1 - (x / cond_transversal) if (x &gt;= 0 and x &lt; cond_transversal) else 0 for x in self.dist_al_electrodo])

    def calcular_wlong(self, funcion, matriz_nodos):
        &#34;&#34;&#34;Método para calcular los pesos longitudinales para cada nodo de cada fibra.

        Args:
            funcion (Callable): Función con la cual se calcularán los pesos longitudinales (Wlong).
            matriz_nodos (list): Lista con la información de la ubicación de nodos de cada fibra.
        &#34;&#34;&#34;
        a = self.grosor / 2
        d = self.zona_influencia
        v = self.valor
        if funcion == funcion_constante:
            wlong = np.array(
                [np.array([funcion_constante(x=x, z=self.z, a=a, d=d, v=v) for x in lista]) for lista in matriz_nodos])
        else:
            wlong = np.array([np.array([funcion(x=x, z=self.z, a=a, d=d) for x in lista]) for lista in matriz_nodos],
                             dtype=object)
        self.wlong = wlong

    def calcular_pesos(self, nervio, funcion, matriz_nodos):
        &#34;&#34;&#34;Método que calcula los pesos en cada nodo para cada fibra del nervio.

        Args:
            nervio (Nervio): Objeto de la clase Nervio. Nervio que contiene las fibras.
            funcion (Callable): Función con la cual se calcularán los pesos longitudinales (Wlong).
            matriz_nodos (list): Lista con la ubicación de los nodos de cada fibra.
        &#34;&#34;&#34;
        self.calcular_wmax(nervio)
        self.calcular_wlong(funcion, matriz_nodos)

        self.pesos = np.array([
            np.array([wlong - (1 - wmax) if (wlong - (1 - wmax)) &gt;= 0 else 0
                      for wlong in lista_wlong])
            for wmax, lista_wlong in zip(self.wmax, self.wlong)
        ],
                              dtype=object)

    def sfap_funcion(self, frec_muestreo, velocidad_fibras, tiempo_registro, estimulo, ubicacion_nodos, num_fibras):
        &#34;&#34;&#34;Método que calcula los Potenciales de Acción de Fibra Unica para cada fibra que se encuentra en el Nervio.

        Args:
            frec_muestreo (float): Frecuencia de muestreo. En Hz.
            velocidad_fibras (float): Velocidad de conducción de una fibra. En m/s.
            tiempo_registro (float): Tiempo en el que se realiza el registro. En segundos.
            estimulo (numpy.ndarray): Array con los estímulos por fibra. 
            ubicacion_nodos (numpy.ndarray): Array con la ubicación de los nodos en todas las fibras.
            num_fibras (int): Cantidad de fibras en el nervio.
        &#34;&#34;&#34;
        total_muestras = int(tiempo_registro * frec_muestreo)
        sfap_matriz = np.zeros((len(ubicacion_nodos), total_muestras))
        for i, posiciones in enumerate(ubicacion_nodos):
            estimulo_por_nodo = array_to_multiarray(array=posiciones,
                                                    estimulo=estimulo[i],
                                                    fm=frec_muestreo,
                                                    tiempo_registro=tiempo_registro,
                                                    velocidad=velocidad_fibras[i],
                                                    peso=self.pesos[i])
            sfap = np.sum(estimulo_por_nodo, axis=0)
            sfap_matriz[i] = sfap
        self.sfap = sfap_matriz / num_fibras

    def cap_funcion(self):
        &#34;&#34;&#34;Función que calcula el Potencial de Acción Compuesto captado por el electrodo.
        &#34;&#34;&#34;
        self.cap = np.sum(self.sfap, axis=0)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="simulacion.Electrodo.calcular_distancias"><code class="name flex">
<span>def <span class="ident">calcular_distancias</span></span>(<span>self, lista_fibras, tipo_fibra)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para calcular distancias desde el electrodo a las fibras.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lista_fibras</code></strong> :&ensp;<code>list</code></dt>
<dd>Lista de objetos Fibra.</dd>
<dt><strong><code>tipo_fibra</code></strong> :&ensp;<code>str</code></dt>
<dd>Consideracion de la fibra para calcular distancias. Puede ser 'puntual' o 'no_puntual'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcular_distancias(self, lista_fibras, tipo_fibra):
    &#34;&#34;&#34;Método para calcular distancias desde el electrodo a las fibras.

    Args:
        lista_fibras (list): Lista de objetos Fibra.
        tipo_fibra (str): Consideracion de la fibra para calcular distancias. Puede ser &#39;puntual&#39; o &#39;no_puntual&#39;.
    &#34;&#34;&#34;
    if tipo_fibra == TipoFibra.puntual.name:
        self.dist_al_electrodo = np.array([self.shape.distance(Point(f.x, f.y)) for f in lista_fibras])
    elif tipo_fibra == TipoFibra.no_puntual.name:
        self.dist_al_electrodo = np.array(
            [self.shape.distance(Point(f.x, f.y).buffer(f.radio)) for f in lista_fibras])
    else:
        raise TypeError(&#34;El tipo de fibra ingresado no es correcto.&#34;)</code></pre>
</details>
</dd>
<dt id="simulacion.Electrodo.calcular_pesos"><code class="name flex">
<span>def <span class="ident">calcular_pesos</span></span>(<span>self, nervio, funcion, matriz_nodos)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que calcula los pesos en cada nodo para cada fibra del nervio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nervio</code></strong> :&ensp;<code><a title="simulacion.Nervio" href="#simulacion.Nervio">Nervio</a></code></dt>
<dd>Objeto de la clase Nervio. Nervio que contiene las fibras.</dd>
<dt><strong><code>funcion</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Función con la cual se calcularán los pesos longitudinales (Wlong).</dd>
<dt><strong><code>matriz_nodos</code></strong> :&ensp;<code>list</code></dt>
<dd>Lista con la ubicación de los nodos de cada fibra.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcular_pesos(self, nervio, funcion, matriz_nodos):
    &#34;&#34;&#34;Método que calcula los pesos en cada nodo para cada fibra del nervio.

    Args:
        nervio (Nervio): Objeto de la clase Nervio. Nervio que contiene las fibras.
        funcion (Callable): Función con la cual se calcularán los pesos longitudinales (Wlong).
        matriz_nodos (list): Lista con la ubicación de los nodos de cada fibra.
    &#34;&#34;&#34;
    self.calcular_wmax(nervio)
    self.calcular_wlong(funcion, matriz_nodos)

    self.pesos = np.array([
        np.array([wlong - (1 - wmax) if (wlong - (1 - wmax)) &gt;= 0 else 0
                  for wlong in lista_wlong])
        for wmax, lista_wlong in zip(self.wmax, self.wlong)
    ],
                          dtype=object)</code></pre>
</details>
</dd>
<dt id="simulacion.Electrodo.calcular_wlong"><code class="name flex">
<span>def <span class="ident">calcular_wlong</span></span>(<span>self, funcion, matriz_nodos)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para calcular los pesos longitudinales para cada nodo de cada fibra.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>funcion</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Función con la cual se calcularán los pesos longitudinales (Wlong).</dd>
<dt><strong><code>matriz_nodos</code></strong> :&ensp;<code>list</code></dt>
<dd>Lista con la información de la ubicación de nodos de cada fibra.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcular_wlong(self, funcion, matriz_nodos):
    &#34;&#34;&#34;Método para calcular los pesos longitudinales para cada nodo de cada fibra.

    Args:
        funcion (Callable): Función con la cual se calcularán los pesos longitudinales (Wlong).
        matriz_nodos (list): Lista con la información de la ubicación de nodos de cada fibra.
    &#34;&#34;&#34;
    a = self.grosor / 2
    d = self.zona_influencia
    v = self.valor
    if funcion == funcion_constante:
        wlong = np.array(
            [np.array([funcion_constante(x=x, z=self.z, a=a, d=d, v=v) for x in lista]) for lista in matriz_nodos])
    else:
        wlong = np.array([np.array([funcion(x=x, z=self.z, a=a, d=d) for x in lista]) for lista in matriz_nodos],
                         dtype=object)
    self.wlong = wlong</code></pre>
</details>
</dd>
<dt id="simulacion.Electrodo.calcular_wmax"><code class="name flex">
<span>def <span class="ident">calcular_wmax</span></span>(<span>self, nervio)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para calcular los pesos transversales (Wmax) para cada fibra del nervio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nervio</code></strong> :&ensp;<code><a title="simulacion.Nervio" href="#simulacion.Nervio">Nervio</a></code></dt>
<dd>El nervio que contiene las fibras a las cuales se les calculará el Wmax.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcular_wmax(self, nervio):
    &#34;&#34;&#34;Método para calcular los pesos transversales (Wmax) para cada fibra del nervio.

    Args:
        nervio (Nervio): El nervio que contiene las fibras a las cuales se les calculará el Wmax.
    &#34;&#34;&#34;
    if nervio.conductividad_transversal is not None:
        cond_transversal = nervio.conductividad_transversal * max(self.dist_al_electrodo)
    else:
        cond_transversal = nervio.porcentaje_cobertura / 100 * max(self.dist_al_electrodo)

    self.wmax = np.array(
        [1 - (x / cond_transversal) if (x &gt;= 0 and x &lt; cond_transversal) else 0 for x in self.dist_al_electrodo])</code></pre>
</details>
</dd>
<dt id="simulacion.Electrodo.cap_funcion"><code class="name flex">
<span>def <span class="ident">cap_funcion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Función que calcula el Potencial de Acción Compuesto captado por el electrodo.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cap_funcion(self):
    &#34;&#34;&#34;Función que calcula el Potencial de Acción Compuesto captado por el electrodo.
    &#34;&#34;&#34;
    self.cap = np.sum(self.sfap, axis=0)</code></pre>
</details>
</dd>
<dt id="simulacion.Electrodo.info_electrodo"><code class="name flex">
<span>def <span class="ident">info_electrodo</span></span>(<span>self, idx)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que genera un diccionario con información del electrodo.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Ubicación del electrodo en la lista de electrodos de la clase Entorno.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Devuelve un diccionario con información del electrodo.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info_electrodo(self, idx):
    &#34;&#34;&#34;Método que genera un diccionario con información del electrodo.

    Args:
        idx (int): Ubicación del electrodo en la lista de electrodos de la clase Entorno.

    Returns:
        dict: Devuelve un diccionario con información del electrodo.
    &#34;&#34;&#34;
    return {
        &#34;electrodo_numero&#34;: idx,
        &#34;tipo&#34;: self.tipo,
        &#34;posicion_transversal_electrodo&#34;: [self.x, self.y],
        &#34;posicion_longitudinal_electrodo&#34;: self.z,
        &#34;espesor&#34;: self.grosor,
        &#34;zona_de_influencia&#34;: self.zona_influencia,
    }</code></pre>
</details>
</dd>
<dt id="simulacion.Electrodo.ploteo_electrodo"><code class="name flex">
<span>def <span class="ident">ploteo_electrodo</span></span>(<span>self, idx)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que dibuja al electrodo en el espacio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>Ubicación del electrodo en la lista de electrodos de la clase Entorno.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ploteo_electrodo(self, idx):
    &#34;&#34;&#34;Método que dibuja al electrodo en el espacio.

    Args:
        idx (int): Ubicación del electrodo en la lista de electrodos de la clase Entorno.
    &#34;&#34;&#34;
    if self.tipo == TipoElectrodo.punto.name:
        x, y = self.shape.x, self.shape.y
        plt.plot(x, y, &#39;o&#39;, label=f&#34;Electrodo {idx}&#34;)
    elif self.tipo in (TipoElectrodo.circulo.name, TipoElectrodo.poligono.name):
        x, y = self.shape.exterior.xy
        plt.plot(x, y, label=f&#34;Electrodo {idx}&#34;)</code></pre>
</details>
</dd>
<dt id="simulacion.Electrodo.sfap_funcion"><code class="name flex">
<span>def <span class="ident">sfap_funcion</span></span>(<span>self, frec_muestreo, velocidad_fibras, tiempo_registro, estimulo, ubicacion_nodos, num_fibras)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que calcula los Potenciales de Acción de Fibra Unica para cada fibra que se encuentra en el Nervio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frec_muestreo</code></strong> :&ensp;<code>float</code></dt>
<dd>Frecuencia de muestreo. En Hz.</dd>
<dt><strong><code>velocidad_fibras</code></strong> :&ensp;<code>float</code></dt>
<dd>Velocidad de conducción de una fibra. En m/s.</dd>
<dt><strong><code>tiempo_registro</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo en el que se realiza el registro. En segundos.</dd>
<dt><strong><code>estimulo</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array con los estímulos por fibra. </dd>
<dt><strong><code>ubicacion_nodos</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array con la ubicación de los nodos en todas las fibras.</dd>
<dt><strong><code>num_fibras</code></strong> :&ensp;<code>int</code></dt>
<dd>Cantidad de fibras en el nervio.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sfap_funcion(self, frec_muestreo, velocidad_fibras, tiempo_registro, estimulo, ubicacion_nodos, num_fibras):
    &#34;&#34;&#34;Método que calcula los Potenciales de Acción de Fibra Unica para cada fibra que se encuentra en el Nervio.

    Args:
        frec_muestreo (float): Frecuencia de muestreo. En Hz.
        velocidad_fibras (float): Velocidad de conducción de una fibra. En m/s.
        tiempo_registro (float): Tiempo en el que se realiza el registro. En segundos.
        estimulo (numpy.ndarray): Array con los estímulos por fibra. 
        ubicacion_nodos (numpy.ndarray): Array con la ubicación de los nodos en todas las fibras.
        num_fibras (int): Cantidad de fibras en el nervio.
    &#34;&#34;&#34;
    total_muestras = int(tiempo_registro * frec_muestreo)
    sfap_matriz = np.zeros((len(ubicacion_nodos), total_muestras))
    for i, posiciones in enumerate(ubicacion_nodos):
        estimulo_por_nodo = array_to_multiarray(array=posiciones,
                                                estimulo=estimulo[i],
                                                fm=frec_muestreo,
                                                tiempo_registro=tiempo_registro,
                                                velocidad=velocidad_fibras[i],
                                                peso=self.pesos[i])
        sfap = np.sum(estimulo_por_nodo, axis=0)
        sfap_matriz[i] = sfap
    self.sfap = sfap_matriz / num_fibras</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="simulacion.Entorno"><code class="flex name class">
<span>class <span class="ident">Entorno</span></span>
<span>(</span><span>nombre=None, tiempo_registro=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Entorno.</p>
<p>Metodo constructor de la clase Entorno.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nombre</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nombre del experimento. Por defecto es None.</dd>
<dt><strong><code>tiempo_registro</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tiempo en el cual se realiza el registro de la señal en segundos. Por defecto es None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Entorno:
    &#34;&#34;&#34;Entorno.
    &#34;&#34;&#34;

    def __init__(self, nombre=None, tiempo_registro=None):
        &#34;&#34;&#34;Metodo constructor de la clase Entorno.

        Args:
            nombre (str, optional): Nombre del experimento. Por defecto es None.
            tiempo_registro (float, optional): Tiempo en el cual se realiza el registro de la señal en segundos. Por defecto es None.
        &#34;&#34;&#34;
        self.nombre_experimento = nombre
        self.tiempo_registro = tiempo_registro
        self.nervio = None
        self.electrodos = []
        self.estimulador = None
        self.estimulo = None
        self.frec_muestreo = None
        self.cap_dif = None
        self.capdif_pos1 = None
        self.capdif_pos2 = None

    def crear_nervio(self,
                     diametro,
                     longitud,
                     num_fibras,
                     distancia_nodos,
                     diametro_fibra=None,
                     var_diametro=0,
                     conductividad_transversal=None,
                     porcentaje_cobertura=None,
                     metodo_poblacion=&#39;uniforme_con_superposicion&#39;,
                     semilla=None,
                     alfa=7.6,
                     velocidad=None,
                     variacion_nodos=0,
                     distribucion_variacion=&#39;uniforme&#39;,
                     desplazamiento=0,
                     **kwargs):
        &#34;&#34;&#34;Método para crear un nervio, poblarlo con fibras y agregar nodos a esas fibras.

        Args:
            diametro (float): Diámetro del Nervio. En micrometros.
            longitud (float): Longitud del nervio. En micrometros.
            num_fibras (int): Número de fibras con la que se quiere poblar el nervio.
            distancia_nodos (float): Distancia promedio entre nodos en las fibras. En micrometros.
            diametro_fibra (float): Diámetro de las fibras. En micrometros. Por defecto es None.
            var_diametro (float): Variación en micrometros del diámetro de las fibras con la distribución normal (Sigma). Por defecto es 0.
            conductividad_transversal (float, optional): Conductividad transversal del nervio. Por defecto es None.
            porcentaje_cobertura (float, optional): Porcentaje de alcance del electrodo en el nervio. Por defecto es None.
            metodo_poblacion (str, optional): Método con el cual se quiere poblar el nervio. Pueden ser los del enum PoblacionNervio. Por defecto es &#39;uniforme&#39;.
            semilla (int, optional): Número de la semilla para replicar la distribución. Por defecto es None.
            alfa (float, optional): Valor necesario para el cálculo de la velocidad de conducción de las fibras. En  Por defecto es 7.6. En [m/s/micrometro].
            velocidad (float,optional): Valor de la velocidad de conducción de las fibras. Se asigna a todas las fibras el mismo valor. En m/s.
            variacion (float, optional): Variación de la distancia entre nodos. En micrometros. Por defecto es 0.
            distribucion_variacion (str, optional): Forma de distribución de la variación de los nodos. Puede ser &#39;uniforme&#39; o &#39;normal&#39;. Por defecto es &#39;uniforme&#39;.
            desplazamiento (float, optional): Desplazamiento de todos los nodos en las fibras. En micrometros. Por defecto es 0. 
            
        Keyword Args:
            array_fibras (numpy.ndarray): Numpy array con 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra, en el método de población manual.
            ubicacion_archivo (str): String con la ubicación del archivo csv para el método de población desde_archivo. El archivo csv debe contener 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra.

        &#34;&#34;&#34;
        self.nervio = Nervio(
            diametro=diametro,
            longitud=longitud,
            conductividad_transversal=conductividad_transversal,
            porcentaje_cobertura=porcentaje_cobertura,
        )
        self.nervio.poblar(num_fibras=num_fibras,
                           metodo_poblacion=metodo_poblacion,
                           diametro_fibra=diametro_fibra,
                           var_diametro=var_diametro,
                           alfa=alfa,
                           velocidad=velocidad,
                           semilla=semilla,
                           **kwargs)
        self.nervio.agregar_nodos(distancia_nodos=distancia_nodos,
                                  variacion_nodos=variacion_nodos,
                                  distribucion_variacion=distribucion_variacion,
                                  desplazamiento=desplazamiento)

    def crear_electrodo(self, tipo, zona_influencia, grosor=0, funcion=funcion_trapecio, **kwargs):
        &#34;&#34;&#34;Método para crear un electrodo en el entorno de medición.

        Args:
            tipo (str): Tipo de electrodo. Puede ser los enumerados en el Enum TipoElectrodo.
            zona_influencia (float): Es la zona a cualquiera de los lados a la cual tiene alcance el electrodo. En micrometros.
            grosor (int, optional): Grosor del electrodo en micrometros. Por defecto es 0.
            funcion (Callable, optional): Función con la cual se calcularán los pesos para cada nodo. Por defecto se usa la &#39;funcion_trapecio&#39;.
        
        Keyword Args:
            pos_x (float): Posición del electrodo en el eje x. En micrómetros.
            pos_y (float): Posición del electrodo en el eje y. En micrómetros.
            pos_z (float): Posición del electrodo en el eje z. En micrómetros.
            radio (float): Radio del electrodo tipo Circulo. En micrómetros.
            lista_coordenadas (list): Coordenadas en micrometros del electrodo tipo Poligono.

        Raises:
            ObjectCreationError: Se levanta el error cuando se quiere crear un Electrodo antes de crear un Nervio.
        &#34;&#34;&#34;
        if self.nervio is None:
            raise ObjectCreationError(&#34;Se debe crear un nervio antes de crear un electrodo.&#34;)
        nuevo_electrodo = Electrodo(tipo=tipo, zona_influencia=zona_influencia, grosor=grosor, **kwargs)
        nuevo_electrodo.calcular_distancias(lista_fibras=self.nervio.fibras,
                                            tipo_fibra=kwargs.get(&#39;tipo_fibra&#39;, &#39;puntual&#39;))
        nuevo_electrodo.calcular_pesos(nervio=self.nervio, funcion=funcion, matriz_nodos=self.nervio.informacion_nodos)
        self.electrodos.append(nuevo_electrodo)

    def crear_estimulo(self, tipo_estimulo, frec_muestreo, tiempo_estimulo, **kwargs):
        &#34;&#34;&#34;Método que permite crear el estímulo con el que se excitará el nervio.

        Args:
            tipo_estimulo (str): Tipo de estímulo que se creará. Se detallan en el enum TipoEstimulo. En segundos.
            frec_muestreo (float): Frecuencia de muestreo de la señal. En Hz.
            tiempo_estimulo (float): Tiempo total en el que se realizará la medición. En segundos.
        
        Keyword Args:
            duracion(float): Tiempo en segundos que durará la señal cuadrada. En segundos.
            frec_corte(float): Frecuencia de corte del filtro Butterworth. En Hz.
            orden_filtro(int): Orden del filtro pasa bajos.
            ubicacion_archivo(str): Ubicación del archivo csv con la señal de estimulación.
            array_estimulo(numpy.ndarray): Numpy array con la señal de estimulación para cada fibra.
            tiempo_inicio (float): Momento en el que inicia el estímulo. En segundos.
            lista_inicio (list): Lista con los tiempos de inicio para el tren de señales. En segundos.
            voltaje (float): Voltaje del estímulo. En voltios. Por defecto es 1[V].
        &#34;&#34;&#34;
        self.estimulador = Estimulador(frec_muestreo=frec_muestreo,
                                       tiempo_estimulo=tiempo_estimulo,
                                       num_fibras=self.nervio.cantidad_fibras)
        self.estimulador.crear_estimulo(tipo_estimulo=tipo_estimulo, **kwargs)
        self.estimulo = self.estimulador.estimulo
        self.frec_muestreo = frec_muestreo

        if self.tiempo_registro is None:
            self.tiempo_registro = tiempo_estimulo * 1.5

    def cap(self):
        &#34;&#34;&#34;Método con el cual se obtiene los Potenciales de Acción Compuestos por cada electrodo que se encuentra en el entorno.
        &#34;&#34;&#34;
        for electrodo in self.electrodos:
            electrodo.sfap_funcion(frec_muestreo=self.frec_muestreo,
                                   velocidad_fibras=self.nervio.informacion_fibras()[:, 3],
                                   tiempo_registro=self.tiempo_registro,
                                   estimulo=self.estimulo,
                                   ubicacion_nodos=self.nervio.informacion_nodos,
                                   num_fibras=self.nervio.cantidad_fibras)
            electrodo.cap_funcion()

    def cap_diferencial(self, posicion_1=0, posicion_2=1):
        &#34;&#34;&#34;Método que calcula el Potencial de Accion Diferencial entre dos electrodos.

        Args:
            posicion_1 (int): Posicion del primer electrodo.
            posicion_2 (int): Posicion del segundo electrodo.
        &#34;&#34;&#34;
        self.cap_dif = self.electrodos[posicion_1].cap - self.electrodos[posicion_2].cap
        self.capdif_pos1 = posicion_1
        self.capdif_pos2 = posicion_2

    def informacion_json(self):
        &#34;&#34;&#34;Método que devuelve un archivo JSON con información sobre el nervio, las fibras y los electrodos.
        &#34;&#34;&#34;
        data = {}
        for idx, electrodo in enumerate(self.electrodos):
            data[idx] = {
                &#34;Electrodo&#34;: electrodo.info_electrodo(idx=idx),
                &#34;Nervio&#34;: self.nervio.info_nervio(),
                &#34;Fibras&#34;: [
                    fibra.info_fibra(numero=x, pesos=electrodo.pesos[x], electrodo=electrodo)
                    for x, fibra in enumerate(self.nervio.fibras)
                ],
                &#34;CAP&#34;: electrodo.cap.tolist()
            }
        with open(&#39;data.json&#39;, &#39;w&#39;) as file:
            json.dump(data, file, indent=3)

        del data

    def informe_experimento(self, guardar=False, nombre_archivo=&#34;informe.txt&#34;):
        &#34;&#34;&#34;Método que brinda un informe rápido sobre variables del nervio, electrodos y estimulador. Brinda la posibilidad de guardar la información en un archivo txt.

        Args:
            guardar (bool, optional): Variable que indica si se quiere guardar la información en un archivo txt. Por defecto es False.
        &#34;&#34;&#34;
        ubicaciones_electrodos = [[e.x, e.y, e.z] for e in self.electrodos]
        tipos_electrodos = [e.tipo for e in self.electrodos]
        grosor = [e.grosor for e in self.electrodos]
        zonas = [e.zona_influencia for e in self.electrodos]
        texto = f&#39;&#39;&#39;
NOMBRE DEL EXPERIMENTO: {self.nombre_experimento}

Datos del nervio:
        * Diametro: {2*self.nervio.radio} micrometros
        * Longitud: {self.nervio.longitud_nervio} micrometros
        * Cantidad de fibras: {self.nervio.cantidad_fibras}
        * Posicion del centro del nervio: [{self.nervio.centro_nervio_x},{self.nervio.centro_nervio_y}]
        * Conductividad transversal: {self.nervio.conductividad_transversal}
        * Porcentaje de cobertura del electrodo: {self.nervio.porcentaje_cobertura}
        * Metodo de poblacion: {self.nervio.metodo_poblacion}
        * Distancia entre nodos promedio: {self.nervio.distancia_nodos_promedio}
        
Datos de los electrodos:
        * Cantidad de electrodos: {len(self.electrodos)}
        * Ubicacion de electrodos: {ubicaciones_electrodos}
        * Tipos de electrodos: {tipos_electrodos}
        * Grosor electrodos: {grosor}
        * Zonas de influencia: {zonas}
        
Datos del estimulador:
        * Tipo de estimulo: {self.estimulador.tipo_estimulo}
        * Frecuencia de muestreo: {self.frec_muestreo} Hz
        * Tiempo de estimulo: {self.estimulador.tiempo_estimulo} segundos
        * Tiempo de registro : {self.tiempo_registro} segundos
        &#39;&#39;&#39;
        print(texto)
        if guardar is True:
            with open(nombre_archivo, &#34;w&#34;) as file:
                file.write(texto)

    def archivo_matlab(self, nombre=&#34;info_matlab.mat&#34;):
        &#34;&#34;&#34;Devuelve un archivo .mat para ser usado en Matlab. Incluye información sobre el CAP diferencial, los CAPs con los cuales se calculó el CAP diferencial, el estímulo, y los vectores de tiempo del estímulo y CAPs.

        Args:
            nombre (str): Nombre del archivo .mat
        &#34;&#34;&#34;

        info = {
            &#39;CAPdif&#39;:
                self.cap_dif,
            &#39;CAP1&#39;:
                self.electrodos[self.capdif_pos1].cap,
            &#39;CAP2&#39;:
                self.electrodos[self.capdif_pos2].cap,
            &#39;Vm&#39;:
                self.estimulador.estimulo[0],
            &#39;t_vm&#39;:
                self.estimulador.vector_tiempo,
            &#39;t_cap&#39;:
                np.arange(1 / self.frec_muestreo, 1 / self.frec_muestreo + self.tiempo_registro, 1 / self.frec_muestreo)
        }
        savemat(nombre, info)
        del info

    def quitar_electrodo(self, posicion):
        &#34;&#34;&#34;Método para quitar un electrodo.

        Args:
            posicion (int): Posición del electrodo que se quiere quitar.
        &#34;&#34;&#34;
        del self.electrodos[posicion]

    def dibujar_entorno(self,
                        forma_ploteo=&#39;fibras_sin_diametro&#39;,
                        titulo=&#39;Entorno&#39;,
                        xlabel=&#39;x (μm)&#39;,
                        ylabel=&#39;y (μm)&#39;,
                        borde_nervio=&#39;blue&#39;,
                        relleno_nervio=&#39;None&#39;,
                        guardar=False,
                        nombre_figura=&#34;figura.png&#34;,
                        **kwargs):
        &#34;&#34;&#34;Método para dibujar el entorno de trabajo (nervio, fibras y electrodos).
        Args:
            forma_ploteo (str, optional): Se puede dibujar las fibras con diámetro (fibras_con_diametro) o como fibras puntuales (fibras_sin_diametro). Por defecto es &#39;fibras_sin_diametro&#39;.
            titulo (str, optional): Título de la imagen. Por defecto es &#39;Entorno&#39;.
            xlabel (str, optional): Etiqueta en eje x. Por defecto es &#39;x (μm)&#39;.
            ylabel (str, optional): Etiqueta en eje y. Por defecto es &#39;y (μm)&#39;.
            borde_nervio (str, optional): Color del borde del nervio. Por defecto es &#39;blue&#39;.
            relleno_nervio (str, optional): Color del relleno del nervio. Por defecto es &#39;None&#39;.
            guardar (bool): Parámetro que indica si la imagen se guardará (True) o no (False). Por defecto es False.
            nombre_figura (str): Nombre que se le dará a la figura que se desea guardar. Por defecto es &#34;figura.png&#34;.
        
        Kwargs:
            borde_fibras (str): Color del borde de las fibras. Se aplica cuando FormaDePloteo es &#39;fibras_con_diametro&#39;. Por defecto es &#39;blue&#39;.
            relleno_fibras (str): Color del relleno de las fibras. Se aplica cuando FormaDePloteo es &#39;fibras_con_diametro&#39;. Por defecto es &#39;None&#39;.
            color_fibras (str): Color de las fibras. Se aplica cuando FormaDePloteo es &#39;fibras_sin_diametro&#39;. Por defecto es &#39;red&#39;.

        Raises:
            InputError: Error al introducir una forma de ploteo incorrecta.
        &#34;&#34;&#34;

        fig = plt.figure()

        #Ploteo nervio y fibras
        if forma_ploteo == FormaDePloteo.fibras_sin_diametro.name:
            self.nervio.ploteo_fibras_puntos(borde_nervio=borde_nervio,
                                             relleno_nervio=relleno_nervio,
                                             color_fibras=kwargs.get(&#39;color_fibras&#39;, &#39;red&#39;))
        elif forma_ploteo == FormaDePloteo.fibras_con_diametro.name:
            self.nervio.ploteo_fibras_circulos(borde_nervio=borde_nervio,
                                               relleno_nervio=relleno_nervio,
                                               borde_fibras=kwargs.get(&#39;borde_fibras&#39;, &#39;red&#39;),
                                               relleno_fibras=kwargs.get(&#39;relleno_fibras&#39;, &#39;None&#39;))
        else:
            raise InputError(
                &#39;Ingrese una forma de ploteo correcta. Puede ser \&#39;fibras_con_diametro\&#39; o \&#39;fibras_sin_diametro\&#39; &#39;)

        #Ploteo electrodos
        for idx, electrodo in enumerate(self.electrodos):
            electrodo.ploteo_electrodo(idx=idx)

        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.title(titulo)
        plt.legend(fontsize=&#39;xx-small&#39;)
        plt.axis(&#39;equal&#39;)
        plt.show()

        if guardar is True:
            fig.savefig(nombre_figura, dpi=300, format=&#34;png&#34;)

    def graficas(self, titulo=None, guardar=False, nombre_figura=&#34;figura.png&#34;):
        &#34;&#34;&#34;Método que permite graficar el estímulo, CAP de cada electrodo que se tenga agregado y CAP diferencial de 2 de los electrodos con los cuales se lo obtuvo.

        Args:
            titulo (str, optional): Título del gráfico. Por defecto no hay.
            guardar (bool, optional): Variable que indica si se quiere guardar el dibujo como imagen tipo PNG. Por defecto es False.
            nombre_figura (str, optional): Nombre con el cual se quiere guardar la imagen. Por defecto es &#34;figura.png&#34;.
        &#34;&#34;&#34;
        fig = plt.figure()

        #Vector tiempo
        vector_tiempo = np.arange(1 / self.frec_muestreo, 1 / self.frec_muestreo + self.tiempo_registro,
                                  1 / self.frec_muestreo)

        #CAP
        for idx, electrodo in enumerate(self.electrodos):
            plt.plot(vector_tiempo * 1000, electrodo.cap, label=f&#34;CAP Electrodo n°{idx}&#34;)

        #CAP diferencial
        plt.plot(vector_tiempo * 1000,
                 self.cap_dif,
                 label=f&#34;CAP diferencial electrodos {self.capdif_pos1}-{self.capdif_pos2}&#34;)

        #Vm
        plt.plot(self.estimulador.vector_tiempo * 1000,
                 self.estimulador.estimulo[0],
                 label=&#34;Vm&#34;,
                 color=&#39;gray&#39;,
                 linewidth=0.7)

        plt.title(titulo)
        plt.xlabel(&#39;Tiempo (ms)&#39;)
        plt.ylabel(&#39;Amplitud relativa&#39;)
        plt.legend(fontsize=&#39;small&#39;)
        plt.show()

        if guardar is True:
            fig.savefig(nombre_figura, dpi=300, format=&#34;png&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="simulacion.Entorno.archivo_matlab"><code class="name flex">
<span>def <span class="ident">archivo_matlab</span></span>(<span>self, nombre='info_matlab.mat')</span>
</code></dt>
<dd>
<div class="desc"><p>Devuelve un archivo .mat para ser usado en Matlab. Incluye información sobre el CAP diferencial, los CAPs con los cuales se calculó el CAP diferencial, el estímulo, y los vectores de tiempo del estímulo y CAPs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nombre</code></strong> :&ensp;<code>str</code></dt>
<dd>Nombre del archivo .mat</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def archivo_matlab(self, nombre=&#34;info_matlab.mat&#34;):
    &#34;&#34;&#34;Devuelve un archivo .mat para ser usado en Matlab. Incluye información sobre el CAP diferencial, los CAPs con los cuales se calculó el CAP diferencial, el estímulo, y los vectores de tiempo del estímulo y CAPs.

    Args:
        nombre (str): Nombre del archivo .mat
    &#34;&#34;&#34;

    info = {
        &#39;CAPdif&#39;:
            self.cap_dif,
        &#39;CAP1&#39;:
            self.electrodos[self.capdif_pos1].cap,
        &#39;CAP2&#39;:
            self.electrodos[self.capdif_pos2].cap,
        &#39;Vm&#39;:
            self.estimulador.estimulo[0],
        &#39;t_vm&#39;:
            self.estimulador.vector_tiempo,
        &#39;t_cap&#39;:
            np.arange(1 / self.frec_muestreo, 1 / self.frec_muestreo + self.tiempo_registro, 1 / self.frec_muestreo)
    }
    savemat(nombre, info)
    del info</code></pre>
</details>
</dd>
<dt id="simulacion.Entorno.cap"><code class="name flex">
<span>def <span class="ident">cap</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Método con el cual se obtiene los Potenciales de Acción Compuestos por cada electrodo que se encuentra en el entorno.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cap(self):
    &#34;&#34;&#34;Método con el cual se obtiene los Potenciales de Acción Compuestos por cada electrodo que se encuentra en el entorno.
    &#34;&#34;&#34;
    for electrodo in self.electrodos:
        electrodo.sfap_funcion(frec_muestreo=self.frec_muestreo,
                               velocidad_fibras=self.nervio.informacion_fibras()[:, 3],
                               tiempo_registro=self.tiempo_registro,
                               estimulo=self.estimulo,
                               ubicacion_nodos=self.nervio.informacion_nodos,
                               num_fibras=self.nervio.cantidad_fibras)
        electrodo.cap_funcion()</code></pre>
</details>
</dd>
<dt id="simulacion.Entorno.cap_diferencial"><code class="name flex">
<span>def <span class="ident">cap_diferencial</span></span>(<span>self, posicion_1=0, posicion_2=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que calcula el Potencial de Accion Diferencial entre dos electrodos.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>posicion_1</code></strong> :&ensp;<code>int</code></dt>
<dd>Posicion del primer electrodo.</dd>
<dt><strong><code>posicion_2</code></strong> :&ensp;<code>int</code></dt>
<dd>Posicion del segundo electrodo.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cap_diferencial(self, posicion_1=0, posicion_2=1):
    &#34;&#34;&#34;Método que calcula el Potencial de Accion Diferencial entre dos electrodos.

    Args:
        posicion_1 (int): Posicion del primer electrodo.
        posicion_2 (int): Posicion del segundo electrodo.
    &#34;&#34;&#34;
    self.cap_dif = self.electrodos[posicion_1].cap - self.electrodos[posicion_2].cap
    self.capdif_pos1 = posicion_1
    self.capdif_pos2 = posicion_2</code></pre>
</details>
</dd>
<dt id="simulacion.Entorno.crear_electrodo"><code class="name flex">
<span>def <span class="ident">crear_electrodo</span></span>(<span>self, tipo, zona_influencia, grosor=0, funcion=&lt;function funcion_trapecio&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para crear un electrodo en el entorno de medición.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tipo</code></strong> :&ensp;<code>str</code></dt>
<dd>Tipo de electrodo. Puede ser los enumerados en el Enum TipoElectrodo.</dd>
<dt><strong><code>zona_influencia</code></strong> :&ensp;<code>float</code></dt>
<dd>Es la zona a cualquiera de los lados a la cual tiene alcance el electrodo. En micrometros.</dd>
<dt><strong><code>grosor</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Grosor del electrodo en micrometros. Por defecto es 0.</dd>
<dt><strong><code>funcion</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>Función con la cual se calcularán los pesos para cada nodo. Por defecto se usa la 'funcion_trapecio'.</dd>
</dl>

<h2 id="args">Keyword Args</h2>
<dl>
<dt><strong><code>pos_x</code></strong> :&ensp;<code>float</code></dt>
<dd>Posición del electrodo en el eje x. En micrómetros.</dd>
<dt><strong><code>pos_y</code></strong> :&ensp;<code>float</code></dt>
<dd>Posición del electrodo en el eje y. En micrómetros.</dd>
<dt><strong><code>pos_z</code></strong> :&ensp;<code>float</code></dt>
<dd>Posición del electrodo en el eje z. En micrómetros.</dd>
<dt><strong><code>radio</code></strong> :&ensp;<code>float</code></dt>
<dd>Radio del electrodo tipo Circulo. En micrómetros.</dd>
<dt><strong><code>lista_coordenadas</code></strong> :&ensp;<code>list</code></dt>
<dd>Coordenadas en micrómetros del electrodo tipo Poligono.</dd>
</dl>

<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="simulacion.ObjectCreationError" href="#simulacion.ObjectCreationError">ObjectCreationError</a></code></dt>
<dd>Se levanta el error cuando se quiere crear un Electrodo antes de crear un Nervio.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crear_electrodo(self, tipo, zona_influencia, grosor=0, funcion=funcion_trapecio, **kwargs):
    &#34;&#34;&#34;Método para crear un electrodo en el entorno de medición.

    Args:
        tipo (str): Tipo de electrodo. Puede ser los enumerados en el Enum TipoElectrodo.
        zona_influencia (float): Es la zona a cualquiera de los lados a la cual tiene alcance el electrodo. En micrometros.
        grosor (int, optional): Grosor del electrodo en micrometros. Por defecto es 0.
        funcion (Callable, optional): Función con la cual se calcularán los pesos para cada nodo. Por defecto se usa la &#39;funcion_trapecio&#39;.
    
    Keyword Args:
        pos_x (float): Posición del electrodo en el eje x. En micrómetros.
        pos_y (float): Posición del electrodo en el eje y. En micrómetros.
        pos_z (float): Posición del electrodo en el eje z. En micrómetros.
        radio (float): Radio del electrodo tipo Circulo. En micrómetros.
        lista_coordenadas (list): Coordenadas en micrometros del electrodo tipo Poligono.

    Raises:
        ObjectCreationError: Se levanta el error cuando se quiere crear un Electrodo antes de crear un Nervio.
    &#34;&#34;&#34;
    if self.nervio is None:
        raise ObjectCreationError(&#34;Se debe crear un nervio antes de crear un electrodo.&#34;)
    nuevo_electrodo = Electrodo(tipo=tipo, zona_influencia=zona_influencia, grosor=grosor, **kwargs)
    nuevo_electrodo.calcular_distancias(lista_fibras=self.nervio.fibras,
                                        tipo_fibra=kwargs.get(&#39;tipo_fibra&#39;, &#39;puntual&#39;))
    nuevo_electrodo.calcular_pesos(nervio=self.nervio, funcion=funcion, matriz_nodos=self.nervio.informacion_nodos)
    self.electrodos.append(nuevo_electrodo)</code></pre>
</details>
</dd>
<dt id="simulacion.Entorno.crear_estimulo"><code class="name flex">
<span>def <span class="ident">crear_estimulo</span></span>(<span>self, tipo_estimulo, frec_muestreo, tiempo_estimulo, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que permite crear el estímulo con el que se excitará el nervio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tipo_estimulo</code></strong> :&ensp;<code>str</code></dt>
<dd>Tipo de estímulo que se creará. Se detallan en el enum TipoEstimulo. En segundos.</dd>
<dt><strong><code>frec_muestreo</code></strong> :&ensp;<code>float</code></dt>
<dd>Frecuencia de muestreo de la señal. En Hz.</dd>
<dt><strong><code>tiempo_estimulo</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo total en el que se realizará la medición. En segundos.</dd>
</dl>

<h2 id="args">Keyword Args</h2>
<dl>
<dt><strong><code>duracion</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo en segundos que durará la señal cuadrada. En segundos.</dd>
<dt><strong><code>frec_corte</code></strong> :&ensp;<code>float</code></dt>
<dd>Frecuencia de corte del filtro Butterworth. En Hz.</dd>
<dt><strong><code>orden_filtro</code></strong> :&ensp;<code>int</code></dt>
<dd>Orden del filtro pasa bajos.</dd>
<dt><strong><code>ubicacion_archivo</code></strong> :&ensp;<code>str</code></dt>
<dd>Ubicación del archivo csv con la señal de estimulación.</dd>
<dt><strong><code>array_estimulo</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Numpy array con la señal de estimulación para cada fibra.</dd>
<dt><strong><code>tiempo_inicio</code></strong> :&ensp;<code>float</code></dt>
<dd>Momento en el que inicia el estímulo. En segundos.</dd>
<dt><strong><code>lista_inicio</code></strong> :&ensp;<code>list</code></dt>
<dd>Lista con los tiempos de inicio para el tren de señales. En segundos.</dd>
<dt><strong><code>voltaje</code></strong> :&ensp;<code>float</code></dt>
<dd>Voltaje del estímulo. En voltios. Por defecto es 1[V].</dd>
</dl>

<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crear_estimulo(self, tipo_estimulo, frec_muestreo, tiempo_estimulo, **kwargs):
    &#34;&#34;&#34;Método que permite crear el estímulo con el que se excitará el nervio.

    Args:
        tipo_estimulo (str): Tipo de estímulo que se creará. Se detallan en el enum TipoEstimulo. En segundos.
        frec_muestreo (float): Frecuencia de muestreo de la señal. En Hz.
        tiempo_estimulo (float): Tiempo total en el que se realizará la medición. En segundos.
    
    Keyword Args:
        duracion(float): Tiempo en segundos que durará la señal cuadrada. En segundos.
        frec_corte(float): Frecuencia de corte del filtro Butterworth. En Hz.
        orden_filtro(int): Orden del filtro pasa bajos.
        ubicacion_archivo(str): Ubicación del archivo csv con la señal de estimulación.
        array_estimulo(numpy.ndarray): Numpy array con la señal de estimulación para cada fibra.
        tiempo_inicio (float): Momento en el que inicia el estímulo. En segundos.
        lista_inicio (list): Lista con los tiempos de inicio para el tren de señales. En segundos.
        voltaje (float): Voltaje del estímulo. En voltios. Por defecto es 1[V].
    &#34;&#34;&#34;
    self.estimulador = Estimulador(frec_muestreo=frec_muestreo,
                                   tiempo_estimulo=tiempo_estimulo,
                                   num_fibras=self.nervio.cantidad_fibras)
    self.estimulador.crear_estimulo(tipo_estimulo=tipo_estimulo, **kwargs)
    self.estimulo = self.estimulador.estimulo
    self.frec_muestreo = frec_muestreo

    if self.tiempo_registro is None:
        self.tiempo_registro = tiempo_estimulo * 1.5</code></pre>
</details>
</dd>
<dt id="simulacion.Entorno.crear_nervio"><code class="name flex">
<span>def <span class="ident">crear_nervio</span></span>(<span>self, diametro, longitud, num_fibras, distancia_nodos, diametro_fibra=None, var_diametro=0, conductividad_transversal=None, porcentaje_cobertura=None, metodo_poblacion='uniforme_con_superposicion', semilla=None, alfa=7.6, velocidad=None, variacion_nodos=0, distribucion_variacion='uniforme', desplazamiento=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para crear un nervio, poblarlo con fibras y agregar nodos a esas fibras.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>diametro</code></strong> :&ensp;<code>float</code></dt>
<dd>Diámetro del Nervio. En micrometros.</dd>
<dt><strong><code>longitud</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitud del nervio. En micrometros.</dd>
<dt><strong><code>num_fibras</code></strong> :&ensp;<code>int</code></dt>
<dd>Número de fibras con la que se quiere poblar el nervio.</dd>
<dt><strong><code>distancia_nodos</code></strong> :&ensp;<code>float</code></dt>
<dd>Distancia promedio entre nodos en las fibras. En micrometros.</dd>
<dt><strong><code>diametro_fibra</code></strong> :&ensp;<code>float</code></dt>
<dd>Diámetro de las fibras. En micrometros. Por defecto es None.</dd>
<dt><strong><code>var_diametro</code></strong> :&ensp;<code>float</code></dt>
<dd>Variación en micrometros del diámetro de las fibras con la distribución normal (Sigma). Por defecto es 0.</dd>
<dt><strong><code>conductividad_transversal</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Conductividad transversal del nervio. Por defecto es None.</dd>
<dt><strong><code>porcentaje_cobertura</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Porcentaje de alcance del electrodo en el nervio. Por defecto es None.</dd>
<dt><strong><code>metodo_poblacion</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Método con el cual se quiere poblar el nervio. Pueden ser los del enum PoblacionNervio. Por defecto es 'uniforme'.</dd>
<dt><strong><code>semilla</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Número de la semilla para replicar la distribución. Por defecto es None.</dd>
<dt><strong><code>alfa</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Valor necesario para el cálculo de la velocidad de conducción de las fibras. En
Por defecto es 7.6. En [m/s/micrometro].</dd>
<dt><strong><code>velocidad</code></strong> :&ensp;<code>float</code>,optional</dt>
<dd>Valor de la velocidad de conducción de las fibras. Se asigna a todas las fibras el mismo valor. En m/s.</dd>
<dt><strong><code>variacion</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Variación de la distancia entre nodos. En micrometros. Por defecto es 0.</dd>
<dt><strong><code>distribucion_variacion</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Forma de distribución de la variación de los nodos. Puede ser 'uniforme' o 'normal'. Por defecto es 'uniforme'.</dd>
<dt><strong><code>desplazamiento</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Desplazamiento de todos los nodos en las fibras. En micrometros. Por defecto es 0. </dd>
</dl>

<h2 id="args">Keyword Args</h2>
<dl>
<dt><strong><code>array_fibras</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Numpy array con 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra, en el método de población manual.</dd>
<dt><strong><code>ubicacion_archivo</code></strong> :&ensp;<code>str</code></dt>
<dd>String con la ubicación del archivo csv para el método de población desde_archivo. El archivo csv debe contener 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra.</dd>
</dl>

<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crear_nervio(self,
                 diametro,
                 longitud,
                 num_fibras,
                 distancia_nodos,
                 diametro_fibra=None,
                 var_diametro=0,
                 conductividad_transversal=None,
                 porcentaje_cobertura=None,
                 metodo_poblacion=&#39;uniforme_con_superposicion&#39;,
                 semilla=None,
                 alfa=7.6,
                 velocidad=None,
                 variacion_nodos=0,
                 distribucion_variacion=&#39;uniforme&#39;,
                 desplazamiento=0,
                 **kwargs):
    &#34;&#34;&#34;Método para crear un nervio, poblarlo con fibras y agregar nodos a esas fibras.

    Args:
        diametro (float): Diámetro del Nervio. En micrometros.
        longitud (float): Longitud del nervio. En micrometros.
        num_fibras (int): Número de fibras con la que se quiere poblar el nervio.
        distancia_nodos (float): Distancia promedio entre nodos en las fibras. En micrometros.
        diametro_fibra (float): Diámetro de las fibras. En micrometros. Por defecto es None.
        var_diametro (float): Variación en micrometros del diámetro de las fibras con la distribución normal (Sigma). Por defecto es 0.
        conductividad_transversal (float, optional): Conductividad transversal del nervio. Por defecto es None.
        porcentaje_cobertura (float, optional): Porcentaje de alcance del electrodo en el nervio. Por defecto es None.
        metodo_poblacion (str, optional): Método con el cual se quiere poblar el nervio. Pueden ser los del enum PoblacionNervio. Por defecto es &#39;uniforme&#39;.
        semilla (int, optional): Número de la semilla para replicar la distribución. Por defecto es None.
        alfa (float, optional): Valor necesario para el cálculo de la velocidad de conducción de las fibras. En  Por defecto es 7.6. En [m/s/micrometro].
        velocidad (float,optional): Valor de la velocidad de conducción de las fibras. Se asigna a todas las fibras el mismo valor. En m/s.
        variacion (float, optional): Variación de la distancia entre nodos. En micrometros. Por defecto es 0.
        distribucion_variacion (str, optional): Forma de distribución de la variación de los nodos. Puede ser &#39;uniforme&#39; o &#39;normal&#39;. Por defecto es &#39;uniforme&#39;.
        desplazamiento (float, optional): Desplazamiento de todos los nodos en las fibras. En micrometros. Por defecto es 0. 
        
    Keyword Args:
        array_fibras (numpy.ndarray): Numpy array con 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra, en el método de población manual.
        ubicacion_archivo (str): String con la ubicación del archivo csv para el método de población desde_archivo. El archivo csv debe contener 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra.

    &#34;&#34;&#34;
    self.nervio = Nervio(
        diametro=diametro,
        longitud=longitud,
        conductividad_transversal=conductividad_transversal,
        porcentaje_cobertura=porcentaje_cobertura,
    )
    self.nervio.poblar(num_fibras=num_fibras,
                       metodo_poblacion=metodo_poblacion,
                       diametro_fibra=diametro_fibra,
                       var_diametro=var_diametro,
                       alfa=alfa,
                       velocidad=velocidad,
                       semilla=semilla,
                       **kwargs)
    self.nervio.agregar_nodos(distancia_nodos=distancia_nodos,
                              variacion_nodos=variacion_nodos,
                              distribucion_variacion=distribucion_variacion,
                              desplazamiento=desplazamiento)</code></pre>
</details>
</dd>
<dt id="simulacion.Entorno.dibujar_entorno"><code class="name flex">
<span>def <span class="ident">dibujar_entorno</span></span>(<span>self, forma_ploteo='fibras_sin_diametro', titulo='Entorno', xlabel='x (μm)', ylabel='y (μm)', borde_nervio='blue', relleno_nervio='None', guardar=False, nombre_figura='figura.png', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para dibujar el entorno de trabajo (nervio, fibras y electrodos).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>forma_ploteo</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Se puede dibujar las fibras con diámetro (fibras_con_diametro) o como fibras puntuales (fibras_sin_diametro). Por defecto es 'fibras_sin_diametro'.</dd>
<dt><strong><code>titulo</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Título de la imagen. Por defecto es 'Entorno'.</dd>
<dt><strong><code>xlabel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Etiqueta en eje x. Por defecto es 'x (μm)'.</dd>
<dt><strong><code>ylabel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Etiqueta en eje y. Por defecto es 'y (μm)'.</dd>
<dt><strong><code>borde_nervio</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color del borde del nervio. Por defecto es 'blue'.</dd>
<dt><strong><code>relleno_nervio</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color del relleno del nervio. Por defecto es 'None'.</dd>
<dt><strong><code>guardar</code></strong> :&ensp;<code>bool</code></dt>
<dd>Parámetro que indica si la imagen se guardará (True) o no (False). Por defecto es False.</dd>
<dt><strong><code>nombre_figura</code></strong> :&ensp;<code>str</code></dt>
<dd>Nombre que se le dará a la figura que se desea guardar. Por defecto es "figura.png".</dd>
</dl>

<h2 id="kwargs">Keyword Args</h2>
<dl>
<dt><strong><code>borde_fibras</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color del borde de las fibras. Se aplica cuando FormaDePloteo es 'fibras_con_diametro'. Por defecto es 'blue'.</dd>
<dt><strong><code>relleno_fibras</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color del relleno de las fibras. Se aplica cuando FormaDePloteo es 'fibras_con_diametro'. Por defecto es 'None'.</dd>
<dt><strong><code>color_fibras</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color de las fibras. Se aplica cuando FormaDePloteo es 'fibras_sin_diametro'. Por defecto es 'red'.</dd>
</dl>


<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="simulacion.InputError" href="#simulacion.InputError">InputError</a></code></dt>
<dd>Error al introducir una forma de ploteo incorrecta.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dibujar_entorno(self,
                    forma_ploteo=&#39;fibras_sin_diametro&#39;,
                    titulo=&#39;Entorno&#39;,
                    xlabel=&#39;x (μm)&#39;,
                    ylabel=&#39;y (μm)&#39;,
                    borde_nervio=&#39;blue&#39;,
                    relleno_nervio=&#39;None&#39;,
                    guardar=False,
                    nombre_figura=&#34;figura.png&#34;,
                    **kwargs):
    &#34;&#34;&#34;Método para dibujar el entorno de trabajo (nervio, fibras y electrodos).
    Args:
        forma_ploteo (str, optional): Se puede dibujar las fibras con diámetro (fibras_con_diametro) o como fibras puntuales (fibras_sin_diametro). Por defecto es &#39;fibras_sin_diametro&#39;.
        titulo (str, optional): Título de la imagen. Por defecto es &#39;Entorno&#39;.
        xlabel (str, optional): Etiqueta en eje x. Por defecto es &#39;x (μm)&#39;.
        ylabel (str, optional): Etiqueta en eje y. Por defecto es &#39;y (μm)&#39;.
        borde_nervio (str, optional): Color del borde del nervio. Por defecto es &#39;blue&#39;.
        relleno_nervio (str, optional): Color del relleno del nervio. Por defecto es &#39;None&#39;.
        guardar (bool): Parámetro que indica si la imagen se guardará (True) o no (False). Por defecto es False.
        nombre_figura (str): Nombre que se le dará a la figura que se desea guardar. Por defecto es &#34;figura.png&#34;.
    
    Kwargs:
        borde_fibras (str): Color del borde de las fibras. Se aplica cuando FormaDePloteo es &#39;fibras_con_diametro&#39;. Por defecto es &#39;blue&#39;.
        relleno_fibras (str): Color del relleno de las fibras. Se aplica cuando FormaDePloteo es &#39;fibras_con_diametro&#39;. Por defecto es &#39;None&#39;.
        color_fibras (str): Color de las fibras. Se aplica cuando FormaDePloteo es &#39;fibras_sin_diametro&#39;. Por defecto es &#39;red&#39;.

    Raises:
        InputError: Error al introducir una forma de ploteo incorrecta.
    &#34;&#34;&#34;

    fig = plt.figure()

    #Ploteo nervio y fibras
    if forma_ploteo == FormaDePloteo.fibras_sin_diametro.name:
        self.nervio.ploteo_fibras_puntos(borde_nervio=borde_nervio,
                                         relleno_nervio=relleno_nervio,
                                         color_fibras=kwargs.get(&#39;color_fibras&#39;, &#39;red&#39;))
    elif forma_ploteo == FormaDePloteo.fibras_con_diametro.name:
        self.nervio.ploteo_fibras_circulos(borde_nervio=borde_nervio,
                                           relleno_nervio=relleno_nervio,
                                           borde_fibras=kwargs.get(&#39;borde_fibras&#39;, &#39;red&#39;),
                                           relleno_fibras=kwargs.get(&#39;relleno_fibras&#39;, &#39;None&#39;))
    else:
        raise InputError(
            &#39;Ingrese una forma de ploteo correcta. Puede ser \&#39;fibras_con_diametro\&#39; o \&#39;fibras_sin_diametro\&#39; &#39;)

    #Ploteo electrodos
    for idx, electrodo in enumerate(self.electrodos):
        electrodo.ploteo_electrodo(idx=idx)

    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(titulo)
    plt.legend(fontsize=&#39;xx-small&#39;)
    plt.axis(&#39;equal&#39;)
    plt.show()

    if guardar is True:
        fig.savefig(nombre_figura, dpi=300, format=&#34;png&#34;)</code></pre>
</details>
</dd>
<dt id="simulacion.Entorno.graficas"><code class="name flex">
<span>def <span class="ident">graficas</span></span>(<span>self, titulo=None, guardar=False, nombre_figura='figura.png')</span>
</code></dt>
<dd>
<div class="desc"><p>Método que permite graficar el estímulo, CAP de cada electrodo que se tenga agregado y CAP diferencial de 2 de los electrodos con los cuales se lo obtuvo.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>titulo</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Título del gráfico. Por defecto no hay.</dd>
<dt><strong><code>guardar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Variable que indica si se quiere guardar el dibujo como imagen tipo PNG. Por defecto es False.</dd>
<dt><strong><code>nombre_figura</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nombre con el cual se quiere guardar la imagen. Por defecto es "figura.png".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graficas(self, titulo=None, guardar=False, nombre_figura=&#34;figura.png&#34;):
    &#34;&#34;&#34;Método que permite graficar el estímulo, CAP de cada electrodo que se tenga agregado y CAP diferencial de 2 de los electrodos con los cuales se lo obtuvo.

    Args:
        titulo (str, optional): Título del gráfico. Por defecto no hay.
        guardar (bool, optional): Variable que indica si se quiere guardar el dibujo como imagen tipo PNG. Por defecto es False.
        nombre_figura (str, optional): Nombre con el cual se quiere guardar la imagen. Por defecto es &#34;figura.png&#34;.
    &#34;&#34;&#34;
    fig = plt.figure()

    #Vector tiempo
    vector_tiempo = np.arange(1 / self.frec_muestreo, 1 / self.frec_muestreo + self.tiempo_registro,
                              1 / self.frec_muestreo)

    #CAP
    for idx, electrodo in enumerate(self.electrodos):
        plt.plot(vector_tiempo * 1000, electrodo.cap, label=f&#34;CAP Electrodo n°{idx}&#34;)

    #CAP diferencial
    plt.plot(vector_tiempo * 1000,
             self.cap_dif,
             label=f&#34;CAP diferencial electrodos {self.capdif_pos1}-{self.capdif_pos2}&#34;)

    #Vm
    plt.plot(self.estimulador.vector_tiempo * 1000,
             self.estimulador.estimulo[0],
             label=&#34;Vm&#34;,
             color=&#39;gray&#39;,
             linewidth=0.7)

    plt.title(titulo)
    plt.xlabel(&#39;Tiempo (ms)&#39;)
    plt.ylabel(&#39;Amplitud relativa&#39;)
    plt.legend(fontsize=&#39;small&#39;)
    plt.show()

    if guardar is True:
        fig.savefig(nombre_figura, dpi=300, format=&#34;png&#34;)</code></pre>
</details>
</dd>
<dt id="simulacion.Entorno.informacion_json"><code class="name flex">
<span>def <span class="ident">informacion_json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que devuelve un archivo JSON con información sobre el nervio, las fibras y los electrodos.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def informacion_json(self):
    &#34;&#34;&#34;Método que devuelve un archivo JSON con información sobre el nervio, las fibras y los electrodos.
    &#34;&#34;&#34;
    data = {}
    for idx, electrodo in enumerate(self.electrodos):
        data[idx] = {
            &#34;Electrodo&#34;: electrodo.info_electrodo(idx=idx),
            &#34;Nervio&#34;: self.nervio.info_nervio(),
            &#34;Fibras&#34;: [
                fibra.info_fibra(numero=x, pesos=electrodo.pesos[x], electrodo=electrodo)
                for x, fibra in enumerate(self.nervio.fibras)
            ],
            &#34;CAP&#34;: electrodo.cap.tolist()
        }
    with open(&#39;data.json&#39;, &#39;w&#39;) as file:
        json.dump(data, file, indent=3)

    del data</code></pre>
</details>
</dd>
<dt id="simulacion.Entorno.informe_experimento"><code class="name flex">
<span>def <span class="ident">informe_experimento</span></span>(<span>self, guardar=False, nombre_archivo='informe.txt')</span>
</code></dt>
<dd>
<div class="desc"><p>Método que brinda un informe rápido sobre variables del nervio, electrodos y estimulador. Brinda la posibilidad de guardar la información en un archivo txt.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>guardar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Variable que indica si se quiere guardar la información en un archivo txt. Por defecto es False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def informe_experimento(self, guardar=False, nombre_archivo=&#34;informe.txt&#34;):
        &#34;&#34;&#34;Método que brinda un informe rápido sobre variables del nervio, electrodos y estimulador. Brinda la posibilidad de guardar la información en un archivo txt.

        Args:
            guardar (bool, optional): Variable que indica si se quiere guardar la información en un archivo txt. Por defecto es False.
        &#34;&#34;&#34;
        ubicaciones_electrodos = [[e.x, e.y, e.z] for e in self.electrodos]
        tipos_electrodos = [e.tipo for e in self.electrodos]
        grosor = [e.grosor for e in self.electrodos]
        zonas = [e.zona_influencia for e in self.electrodos]
        texto = f&#39;&#39;&#39;
NOMBRE DEL EXPERIMENTO: {self.nombre_experimento}

Datos del nervio:
        * Diametro: {2*self.nervio.radio} micrometros
        * Longitud: {self.nervio.longitud_nervio} micrometros
        * Cantidad de fibras: {self.nervio.cantidad_fibras}
        * Posicion del centro del nervio: [{self.nervio.centro_nervio_x},{self.nervio.centro_nervio_y}]
        * Conductividad transversal: {self.nervio.conductividad_transversal}
        * Porcentaje de cobertura del electrodo: {self.nervio.porcentaje_cobertura}
        * Metodo de poblacion: {self.nervio.metodo_poblacion}
        * Distancia entre nodos promedio: {self.nervio.distancia_nodos_promedio}
        
Datos de los electrodos:
        * Cantidad de electrodos: {len(self.electrodos)}
        * Ubicacion de electrodos: {ubicaciones_electrodos}
        * Tipos de electrodos: {tipos_electrodos}
        * Grosor electrodos: {grosor}
        * Zonas de influencia: {zonas}
        
Datos del estimulador:
        * Tipo de estimulo: {self.estimulador.tipo_estimulo}
        * Frecuencia de muestreo: {self.frec_muestreo} Hz
        * Tiempo de estimulo: {self.estimulador.tiempo_estimulo} segundos
        * Tiempo de registro : {self.tiempo_registro} segundos
        &#39;&#39;&#39;
        print(texto)
        if guardar is True:
            with open(nombre_archivo, &#34;w&#34;) as file:
                file.write(texto)</code></pre>
</details>
</dd>
<dt id="simulacion.Entorno.quitar_electrodo"><code class="name flex">
<span>def <span class="ident">quitar_electrodo</span></span>(<span>self, posicion)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para quitar un electrodo.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>posicion</code></strong> :&ensp;<code>int</code></dt>
<dd>Posición del electrodo que se quiere quitar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quitar_electrodo(self, posicion):
    &#34;&#34;&#34;Método para quitar un electrodo.

    Args:
        posicion (int): Posición del electrodo que se quiere quitar.
    &#34;&#34;&#34;
    del self.electrodos[posicion]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="simulacion.Estimulador"><code class="flex name class">
<span>class <span class="ident">Estimulador</span></span>
<span>(</span><span>frec_muestreo, tiempo_estimulo, num_fibras)</span>
</code></dt>
<dd>
<div class="desc"><p>Encargado de generar el impulso de entrada al Nervio.</p>
<p>Método constructor de la clase Estimulador.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frec_muestreo</code></strong> :&ensp;<code>float</code></dt>
<dd>Frecuencia de muestreo. En Hz.</dd>
<dt><strong><code>tiempo_estimulo</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo total que durará el registro. En segundos.</dd>
<dt><strong><code>num_fibras</code></strong> :&ensp;<code>int</code></dt>
<dd>Número de fibras del nervio.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Estimulador:
    &#34;&#34;&#34;Encargado de generar el impulso de entrada al Nervio.
    &#34;&#34;&#34;

    def __init__(self, frec_muestreo, tiempo_estimulo, num_fibras):
        &#34;&#34;&#34;Método constructor de la clase Estimulador.

        Args:
            frec_muestreo (float): Frecuencia de muestreo. En Hz.
            tiempo_estimulo (float): Tiempo total que durará el registro. En segundos.
            num_fibras (int): Número de fibras del nervio.
        &#34;&#34;&#34;
        self.cant_muestras = int(frec_muestreo * tiempo_estimulo)
        self.frec = frec_muestreo
        self.tiempo_estimulo = tiempo_estimulo
        self.num_fibras = num_fibras
        self.estimulo = None
        self.vector_tiempo = np.arange(1 / self.frec, self.tiempo_estimulo + 1 / self.frec, 1 / self.frec)
        self.tipo_estimulo = None

    def crear_estimulo(self, tipo_estimulo, **kwargs):
        &#34;&#34;&#34;Método para crear el estímulo que se usará con las fibras del nervio.

        Args:
            tipo_estimulo (str): Tipo de estímulo que se creará. Se detallan en el enum TipoEstimulo.
            
        Keyword Args:
            duracion(float): Tiempo en segundos que durará la señal cuadrada.
            tiempo_inicio (float): Momento en el que inicia el estímulo. En segundos.
            lista_tiempo_inicio(list): Lista con los tiempos en segundos en los cuales se quiere tener un potencial de acción.
            frec_corte(float): Frecuencia de corte del filtro Butterworth. En Hz.
            orden_filtro(int): Orden del filtro pasa bajos.
            ubicacion_archivo(str): Ubicación del archivo csv con la señal de estimulación.
            array_estimulo(numpy.ndarray): Numpy array con la señal de estimulación.

        Raises:
            InputError: Se levanta cuando se ingresa un tipo de estímulo no válido.
        &#34;&#34;&#34;
        self.tipo_estimulo = tipo_estimulo
        if tipo_estimulo == TipoEstimulo.cuadrado.name:
            self.estimulo_cuadrado(tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0),
                                   duracion=kwargs.get(&#39;duracion&#39;, 0.0),
                                   voltaje=kwargs.get(&#39;voltaje&#39;, 1))
        elif tipo_estimulo == TipoEstimulo.potencial_de_accion.name:
            self.potencial_de_accion(tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0),
                                     frec_corte=kwargs.get(&#39;frec_corte&#39;, 1000),
                                     orden_filtro=kwargs.get(&#39;orden_filtro&#39;, 2),
                                     lista_inicio=kwargs.get(&#34;lista_inicio&#34;, None))
        elif tipo_estimulo == TipoEstimulo.manual.name:
            self.estimulo_manual(array_estimulo=kwargs.get(&#39;array_estimulo&#39;, None),
                                 tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0))
        elif tipo_estimulo == TipoEstimulo.desde_archivo.name:
            self.estimulo_desde_archivo(tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0),
                                        ubicacion_archivo=kwargs.get(&#39;ubicacion_archivo&#39;, None))
        else:
            raise InputError(&#34;El tipo de impulso ingresado no es correcto.&#34;)

    def estimulo_cuadrado(self, tiempo_inicio, duracion, voltaje):
        &#34;&#34;&#34;Método para crear un estímulo cuadrado o spike.

        Args:
            tiempo_inicio (float): Tiempo en el que se desea iniciar el estímulo. En segundos.
            duracion (float): Tiempo que durará el estímulo. Si es cero, se tendrá una spike. En segundos.
        &#34;&#34;&#34;
        inicio = int(tiempo_inicio * self.frec)
        duracion = duracion * self.frec
        self.estimulo = np.array([
            np.array([voltaje if (j &gt;= inicio and j &lt;= (inicio + duracion)) else 0
                      for j in range(self.cant_muestras)])
            for i in range(self.num_fibras)
        ])

    def potencial_de_accion(self, tiempo_inicio, lista_inicio, frec_corte, orden_filtro):
        &#34;&#34;&#34;Método para crear un potencial de acción.

        Args:
            tiempo_inicio (float): Tiempo en el que se desea iniciar el estímulo. En segundos.
            lista_tiempo_inicio (list): Lista con los tiempos (en segundos) en donde comenzará la señal.
            frec_corte (float): Frecuencia de corte del filtro pasabajos Butterworth. En Hz.
            orden_filtro (int): Orden del filtro Butterworth.
        &#34;&#34;&#34;

        if lista_inicio is not None:
            inicio = [int(i * self.frec) for i in lista_inicio]
        else:
            inicio = int(tiempo_inicio * self.frec)

        #Señal de entrada
        x = np.zeros_like(self.vector_tiempo)
        x[inicio] = 1

        #Filtro Butter
        b, a = signal.butter(orden_filtro, frec_corte / (self.frec / 2))
        Vm = signal.lfilter(b, a, x)
        Vm = Vm / np.max(Vm)  #Vm normalizado

        self.estimulo = np.repeat([Vm], self.num_fibras, axis=0)

    def estimulo_manual(self, array_estimulo, tiempo_inicio):
        &#34;&#34;&#34;Método para crear un estímulo de forma manual, a partir de un array con la señal.

        Args:
            array_estimulo (numpy.ndarray): Señal con la cual se estimularán las fibras del nervio.
            tiempo_inicio (float): Tiempo en el que inicia el estímulo. En segundos.
        &#34;&#34;&#34;
        if len(array_estimulo) != self.num_fibras:
            raise InputError(
                &#34;EL array con la señal del estímulo debe tener tantas filas como fibras haya en el nervio.&#34;)
        estim = np.zeros((len(array_estimulo), self.cant_muestras))
        inicio = int(tiempo_inicio * self.frec)
        flag = False

        if not np.isnan(sum(array_estimulo)).any() and np.issubdtype(array_estimulo.dtype, np.number):
            for i, est in enumerate(array_estimulo):
                muestras_estimulo = len(est)
                if muestras_estimulo &gt; self.cant_muestras - inicio:
                    muestras_estimulo = self.cant_muestras - inicio
                    flag = True
                estim[i][inicio:inicio + muestras_estimulo] = array_estimulo[i][:muestras_estimulo]
        if flag is True:
            print(&#34;Se recortó por lo menos una señal de estímulo debido a su tamaño.&#34;)

        estim_normalizado = estim / np.amax(estim, axis=1, keepdims=True)
        self.estimulo = estim_normalizado

    def estimulo_desde_archivo(self, ubicacion_archivo, tiempo_inicio):
        &#34;&#34;&#34;Método para cargar un estímulo desde un archivo csv.

        Args:
            ubicacion_archivo (str): Ubicación del archivo csv.
            tiempo_inicio (float): Tiempo en el que se iniciará el estímulo. En segundos.

        Raises:
            LoadingError: Error que se levanta cuando no se puede leer el archivo.
        &#34;&#34;&#34;
        try:
            estimulo = np.genfromtxt(ubicacion_archivo, delimiter=&#39;,&#39;)
        except Exception as e:
            raise LoadingError(&#39;Fallo en la carga del archivo.&#39;) from e

        self.estimulo_manual(array_estimulo=estimulo, tiempo_inicio=tiempo_inicio)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="simulacion.Estimulador.crear_estimulo"><code class="name flex">
<span>def <span class="ident">crear_estimulo</span></span>(<span>self, tipo_estimulo, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para crear el estímulo que se usará con las fibras del nervio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tipo_estimulo</code></strong> :&ensp;<code>str</code></dt>
<dd>Tipo de estímulo que se creará. Se detallan en el enum TipoEstimulo.</dd>
</dl>

<h2 id="args">Keyword Args</h2>
<dl>
<dt><strong><code>duracion</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo en segundos que durará la señal cuadrada.</dd>
<dt><strong><code>tiempo_inicio</code></strong> :&ensp;<code>float</code></dt>
<dd>Momento en el que inicia el estímulo. En segundos.</dd>
<dt><strong><code>lista_tiempo_inicio</code></strong> :&ensp;<code>list</code></dt>
<dd>Lista con los tiempos en segundos en los cuales se quiere tener un potencial de acción.</dd>
<dt><strong><code>frec_corte</code></strong> :&ensp;<code>float</code></dt>
<dd>Frecuencia de corte del filtro Butterworth. En Hz.</dd>
<dt><strong><code>orden_filtro</code></strong> :&ensp;<code>int</code></dt>
<dd>Orden del filtro pasa bajos.</dd>
<dt><strong><code>ubicacion_archivo</code></strong> :&ensp;<code>str</code></dt>
<dd>Ubicación del archivo csv con la señal de estimulación.</dd>
<dt><strong><code>array_estimulo</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Numpy array con la señal de estimulación.</dd>
</dl>

<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="simulacion.InputError" href="#simulacion.InputError">InputError</a></code></dt>
<dd>Se levanta cuando se ingresa un tipo de estímulo no válido.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crear_estimulo(self, tipo_estimulo, **kwargs):
    &#34;&#34;&#34;Método para crear el estímulo que se usará con las fibras del nervio.

    Args:
        tipo_estimulo (str): Tipo de estímulo que se creará. Se detallan en el enum TipoEstimulo.
        
    Keyword Args:
        duracion(float): Tiempo en segundos que durará la señal cuadrada.
        tiempo_inicio (float): Momento en el que inicia el estímulo. En segundos.
        lista_tiempo_inicio(list): Lista con los tiempos en segundos en los cuales se quiere tener un potencial de acción.
        frec_corte(float): Frecuencia de corte del filtro Butterworth. En Hz.
        orden_filtro(int): Orden del filtro pasa bajos.
        ubicacion_archivo(str): Ubicación del archivo csv con la señal de estimulación.
        array_estimulo(numpy.ndarray): Numpy array con la señal de estimulación.

    Raises:
        InputError: Se levanta cuando se ingresa un tipo de estímulo no válido.
    &#34;&#34;&#34;
    self.tipo_estimulo = tipo_estimulo
    if tipo_estimulo == TipoEstimulo.cuadrado.name:
        self.estimulo_cuadrado(tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0),
                               duracion=kwargs.get(&#39;duracion&#39;, 0.0),
                               voltaje=kwargs.get(&#39;voltaje&#39;, 1))
    elif tipo_estimulo == TipoEstimulo.potencial_de_accion.name:
        self.potencial_de_accion(tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0),
                                 frec_corte=kwargs.get(&#39;frec_corte&#39;, 1000),
                                 orden_filtro=kwargs.get(&#39;orden_filtro&#39;, 2),
                                 lista_inicio=kwargs.get(&#34;lista_inicio&#34;, None))
    elif tipo_estimulo == TipoEstimulo.manual.name:
        self.estimulo_manual(array_estimulo=kwargs.get(&#39;array_estimulo&#39;, None),
                             tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0))
    elif tipo_estimulo == TipoEstimulo.desde_archivo.name:
        self.estimulo_desde_archivo(tiempo_inicio=kwargs.get(&#34;tiempo_inicio&#34;, 0),
                                    ubicacion_archivo=kwargs.get(&#39;ubicacion_archivo&#39;, None))
    else:
        raise InputError(&#34;El tipo de impulso ingresado no es correcto.&#34;)</code></pre>
</details>
</dd>
<dt id="simulacion.Estimulador.estimulo_cuadrado"><code class="name flex">
<span>def <span class="ident">estimulo_cuadrado</span></span>(<span>self, tiempo_inicio, duracion, voltaje)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para crear un estímulo cuadrado o spike.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tiempo_inicio</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo en el que se desea iniciar el estímulo. En segundos.</dd>
<dt><strong><code>duracion</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo que durará el estímulo. Si es cero, se tendrá una spike. En segundos.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimulo_cuadrado(self, tiempo_inicio, duracion, voltaje):
    &#34;&#34;&#34;Método para crear un estímulo cuadrado o spike.

    Args:
        tiempo_inicio (float): Tiempo en el que se desea iniciar el estímulo. En segundos.
        duracion (float): Tiempo que durará el estímulo. Si es cero, se tendrá una spike. En segundos.
    &#34;&#34;&#34;
    inicio = int(tiempo_inicio * self.frec)
    duracion = duracion * self.frec
    self.estimulo = np.array([
        np.array([voltaje if (j &gt;= inicio and j &lt;= (inicio + duracion)) else 0
                  for j in range(self.cant_muestras)])
        for i in range(self.num_fibras)
    ])</code></pre>
</details>
</dd>
<dt id="simulacion.Estimulador.estimulo_desde_archivo"><code class="name flex">
<span>def <span class="ident">estimulo_desde_archivo</span></span>(<span>self, ubicacion_archivo, tiempo_inicio)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para cargar un estímulo desde un archivo csv.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ubicacion_archivo</code></strong> :&ensp;<code>str</code></dt>
<dd>Ubicación del archivo csv.</dd>
<dt><strong><code>tiempo_inicio</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo en el que se iniciará el estímulo. En segundos.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="simulacion.LoadingError" href="#simulacion.LoadingError">LoadingError</a></code></dt>
<dd>Error que se levanta cuando no se puede leer el archivo.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimulo_desde_archivo(self, ubicacion_archivo, tiempo_inicio):
    &#34;&#34;&#34;Método para cargar un estímulo desde un archivo csv.

    Args:
        ubicacion_archivo (str): Ubicación del archivo csv.
        tiempo_inicio (float): Tiempo en el que se iniciará el estímulo. En segundos.

    Raises:
        LoadingError: Error que se levanta cuando no se puede leer el archivo.
    &#34;&#34;&#34;
    try:
        estimulo = np.genfromtxt(ubicacion_archivo, delimiter=&#39;,&#39;)
    except Exception as e:
        raise LoadingError(&#39;Fallo en la carga del archivo.&#39;) from e

    self.estimulo_manual(array_estimulo=estimulo, tiempo_inicio=tiempo_inicio)</code></pre>
</details>
</dd>
<dt id="simulacion.Estimulador.estimulo_manual"><code class="name flex">
<span>def <span class="ident">estimulo_manual</span></span>(<span>self, array_estimulo, tiempo_inicio)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para crear un estímulo de forma manual, a partir de un array con la señal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array_estimulo</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Señal con la cual se estimularán las fibras del nervio.</dd>
<dt><strong><code>tiempo_inicio</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo en el que inicia el estímulo. En segundos.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimulo_manual(self, array_estimulo, tiempo_inicio):
    &#34;&#34;&#34;Método para crear un estímulo de forma manual, a partir de un array con la señal.

    Args:
        array_estimulo (numpy.ndarray): Señal con la cual se estimularán las fibras del nervio.
        tiempo_inicio (float): Tiempo en el que inicia el estímulo. En segundos.
    &#34;&#34;&#34;
    if len(array_estimulo) != self.num_fibras:
        raise InputError(
            &#34;EL array con la señal del estímulo debe tener tantas filas como fibras haya en el nervio.&#34;)
    estim = np.zeros((len(array_estimulo), self.cant_muestras))
    inicio = int(tiempo_inicio * self.frec)
    flag = False

    if not np.isnan(sum(array_estimulo)).any() and np.issubdtype(array_estimulo.dtype, np.number):
        for i, est in enumerate(array_estimulo):
            muestras_estimulo = len(est)
            if muestras_estimulo &gt; self.cant_muestras - inicio:
                muestras_estimulo = self.cant_muestras - inicio
                flag = True
            estim[i][inicio:inicio + muestras_estimulo] = array_estimulo[i][:muestras_estimulo]
    if flag is True:
        print(&#34;Se recortó por lo menos una señal de estímulo debido a su tamaño.&#34;)

    estim_normalizado = estim / np.amax(estim, axis=1, keepdims=True)
    self.estimulo = estim_normalizado</code></pre>
</details>
</dd>
<dt id="simulacion.Estimulador.potencial_de_accion"><code class="name flex">
<span>def <span class="ident">potencial_de_accion</span></span>(<span>self, tiempo_inicio, lista_inicio, frec_corte, orden_filtro)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para crear un potencial de acción.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tiempo_inicio</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo en el que se desea iniciar el estímulo. En segundos.</dd>
<dt><strong><code>lista_tiempo_inicio</code></strong> :&ensp;<code>list</code></dt>
<dd>Lista con los tiempos (en segundos) en donde comenzará la señal.</dd>
<dt><strong><code>frec_corte</code></strong> :&ensp;<code>float</code></dt>
<dd>Frecuencia de corte del filtro pasabajos Butterworth. En Hz.</dd>
<dt><strong><code>orden_filtro</code></strong> :&ensp;<code>int</code></dt>
<dd>Orden del filtro Butterworth.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def potencial_de_accion(self, tiempo_inicio, lista_inicio, frec_corte, orden_filtro):
    &#34;&#34;&#34;Método para crear un potencial de acción.

    Args:
        tiempo_inicio (float): Tiempo en el que se desea iniciar el estímulo. En segundos.
        lista_tiempo_inicio (list): Lista con los tiempos (en segundos) en donde comenzará la señal.
        frec_corte (float): Frecuencia de corte del filtro pasabajos Butterworth. En Hz.
        orden_filtro (int): Orden del filtro Butterworth.
    &#34;&#34;&#34;

    if lista_inicio is not None:
        inicio = [int(i * self.frec) for i in lista_inicio]
    else:
        inicio = int(tiempo_inicio * self.frec)

    #Señal de entrada
    x = np.zeros_like(self.vector_tiempo)
    x[inicio] = 1

    #Filtro Butter
    b, a = signal.butter(orden_filtro, frec_corte / (self.frec / 2))
    Vm = signal.lfilter(b, a, x)
    Vm = Vm / np.max(Vm)  #Vm normalizado

    self.estimulo = np.repeat([Vm], self.num_fibras, axis=0)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="simulacion.Fibra"><code class="flex name class">
<span>class <span class="ident">Fibra</span></span>
<span>(</span><span>x, y, diametro, velocidad)</span>
</code></dt>
<dd>
<div class="desc"><p>Fibra.</p>
<p>Método constructor de la clase Fibra.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Posición x del centro de la fibra. En micrómetros.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Posición y del centro de la fibra. En micrómetros.</dd>
<dt><strong><code>diametro</code></strong> :&ensp;<code>float</code></dt>
<dd>Diámetro de la fibra. En micrómetros.</dd>
<dt><strong><code>velocidad</code></strong> :&ensp;<code>float</code></dt>
<dd>Velocidad de la fibra en [m/s].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fibra:
    &#34;&#34;&#34;Fibra.
    &#34;&#34;&#34;

    def __init__(self, x, y, diametro, velocidad):
        &#34;&#34;&#34;Método constructor de la clase Fibra.

        Args:
            x (float): Posición x del centro de la fibra. En micrómetros.
            y (float): Posición y del centro de la fibra. En micrómetros.
            diametro (float): Diámetro de la fibra. En micrómetros.
            velocidad (float): Velocidad de la fibra en [m/s].
        &#34;&#34;&#34;
        self.x = x
        self.y = y
        self.radio = diametro / 2
        self.ubicacion_nodos = []
        self.velocidad = velocidad

    def info_fibra(self, numero, pesos, electrodo):
        &#34;&#34;&#34;Método que proporciona un diccionario con información sobre la fibra.

        Args:
            numero (int): Número de fibra.
            pesos (np.ndarray): Array con los pesos de los nodos de las fibras.
            electrodo (Electrodo): Objeto de la clase Electrodo.

        Returns:
            dict: Diccionario con información de la fibra y sus nodos.
        &#34;&#34;&#34;
        datos_fibras = {
            &#34;fibra&#34;: numero,
            &#34;posicion_transversal_fibra&#34;: [self.x, self.y],
            &#34;diametro&#34;: 2 * self.radio,
            &#34;velocidad&#34;: self.velocidad,
            &#34;nodos&#34;: [{
                &#34;ubicacion&#34;: ubicacion,
                &#34;peso&#34;: pesos[i]
            } for i, ubicacion in enumerate(self.ubicacion_nodos)],
            &#34;SFAP&#34;: electrodo.sfap[numero].tolist()
        }
        return datos_fibras

    def obtener_info_fibra(self):
        &#34;&#34;&#34;Método que permite obtener información sobre la fibra, en forma de lista.

        Returns:
            list: Información sobre la fibra (posición en eje x, posición en eje y, radio de la fibra, velocidad de conducción de la fibra).
        &#34;&#34;&#34;
        return [self.x, self.y, self.radio, self.velocidad]

    def ubicar_nodos(self, longitud_fibra, distancia_nodos, variacion, desplazamiento, distribucion_variacion):
        &#34;&#34;&#34;Método para agregar nodos a una fibra.
        Args:
            longitud_fibra (float): Longitud de la fibra en micrómetros.
            distancia_nodos (float): Distancia entre nodos en las fibras en micrómetros.
            variacion (float): Variación de la distancia entre nodos en micrómetros.
            desplazamiento (float): Desplazamiento de los nodos en micrómetros. 
            distribucion_variacion (str): Distribución de la variación de la distancia entre nodos. Se espera un valor correspondiente a alguna de las opciones de VariacionNodos.

        Returns:
            numpy.ndarray: Devuelve un array con la ubicación de los nodos de la fibra.
        &#34;&#34;&#34;
        #arr = np.arange(-longitud_fibra/2,longitud_fibra*1.5 +1,distancia_nodos)
        arr = np.arange(-longitud_fibra / 2, longitud_fibra * 1.5, distancia_nodos)
        if distribucion_variacion == VariacionNodos.uniforme.name:
            var = np.random.uniform(-variacion / 2, variacion / 2, len(arr)) + desplazamiento
        elif distribucion_variacion == VariacionNodos.normal.name:
            var = np.random.normal(0, variacion, len(arr)) + desplazamiento

        ubicacion = arr + var
        ubicacion = ubicacion[(ubicacion &gt; 0) &amp; (ubicacion &lt; longitud_fibra)]
        self.ubicacion_nodos = ubicacion
        return ubicacion</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="simulacion.Fibra.info_fibra"><code class="name flex">
<span>def <span class="ident">info_fibra</span></span>(<span>self, numero, pesos, electrodo)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que proporciona un diccionario con información sobre la fibra.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>numero</code></strong> :&ensp;<code>int</code></dt>
<dd>Número de fibra.</dd>
<dt><strong><code>pesos</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Array con los pesos de los nodos de las fibras.</dd>
<dt><strong><code>electrodo</code></strong> :&ensp;<code><a title="simulacion.Electrodo" href="#simulacion.Electrodo">Electrodo</a></code></dt>
<dd>Objeto de la clase Electrodo.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Diccionario con información de la fibra y sus nodos.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info_fibra(self, numero, pesos, electrodo):
    &#34;&#34;&#34;Método que proporciona un diccionario con información sobre la fibra.

    Args:
        numero (int): Número de fibra.
        pesos (np.ndarray): Array con los pesos de los nodos de las fibras.
        electrodo (Electrodo): Objeto de la clase Electrodo.

    Returns:
        dict: Diccionario con información de la fibra y sus nodos.
    &#34;&#34;&#34;
    datos_fibras = {
        &#34;fibra&#34;: numero,
        &#34;posicion_transversal_fibra&#34;: [self.x, self.y],
        &#34;diametro&#34;: 2 * self.radio,
        &#34;velocidad&#34;: self.velocidad,
        &#34;nodos&#34;: [{
            &#34;ubicacion&#34;: ubicacion,
            &#34;peso&#34;: pesos[i]
        } for i, ubicacion in enumerate(self.ubicacion_nodos)],
        &#34;SFAP&#34;: electrodo.sfap[numero].tolist()
    }
    return datos_fibras</code></pre>
</details>
</dd>
<dt id="simulacion.Fibra.obtener_info_fibra"><code class="name flex">
<span>def <span class="ident">obtener_info_fibra</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que permite obtener información sobre la fibra, en forma de lista.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Información sobre la fibra (posición en eje x, posición en eje y, radio de la fibra, velocidad de conducción de la fibra).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def obtener_info_fibra(self):
    &#34;&#34;&#34;Método que permite obtener información sobre la fibra, en forma de lista.

    Returns:
        list: Información sobre la fibra (posición en eje x, posición en eje y, radio de la fibra, velocidad de conducción de la fibra).
    &#34;&#34;&#34;
    return [self.x, self.y, self.radio, self.velocidad]</code></pre>
</details>
</dd>
<dt id="simulacion.Fibra.ubicar_nodos"><code class="name flex">
<span>def <span class="ident">ubicar_nodos</span></span>(<span>self, longitud_fibra, distancia_nodos, variacion, desplazamiento, distribucion_variacion)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para agregar nodos a una fibra.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>longitud_fibra</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitud de la fibra en micrómetros.</dd>
<dt><strong><code>distancia_nodos</code></strong> :&ensp;<code>float</code></dt>
<dd>Distancia entre nodos en las fibras en micrómetros.</dd>
<dt><strong><code>variacion</code></strong> :&ensp;<code>float</code></dt>
<dd>Variación de la distancia entre nodos en micrómetros.</dd>
<dt><strong><code>desplazamiento</code></strong> :&ensp;<code>float</code></dt>
<dd>Desplazamiento de los nodos en micrómetros. </dd>
<dt><strong><code>distribucion_variacion</code></strong> :&ensp;<code>str</code></dt>
<dd>Distribución de la variación de la distancia entre nodos. Se espera un valor correspondiente a alguna de las opciones de VariacionNodos.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Devuelve un array con la ubicación de los nodos de la fibra.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ubicar_nodos(self, longitud_fibra, distancia_nodos, variacion, desplazamiento, distribucion_variacion):
    &#34;&#34;&#34;Método para agregar nodos a una fibra.
    Args:
        longitud_fibra (float): Longitud de la fibra en micrómetros.
        distancia_nodos (float): Distancia entre nodos en las fibras en micrómetros.
        variacion (float): Variación de la distancia entre nodos en micrómetros.
        desplazamiento (float): Desplazamiento de los nodos en micrómetros. 
        distribucion_variacion (str): Distribución de la variación de la distancia entre nodos. Se espera un valor correspondiente a alguna de las opciones de VariacionNodos.

    Returns:
        numpy.ndarray: Devuelve un array con la ubicación de los nodos de la fibra.
    &#34;&#34;&#34;
    #arr = np.arange(-longitud_fibra/2,longitud_fibra*1.5 +1,distancia_nodos)
    arr = np.arange(-longitud_fibra / 2, longitud_fibra * 1.5, distancia_nodos)
    if distribucion_variacion == VariacionNodos.uniforme.name:
        var = np.random.uniform(-variacion / 2, variacion / 2, len(arr)) + desplazamiento
    elif distribucion_variacion == VariacionNodos.normal.name:
        var = np.random.normal(0, variacion, len(arr)) + desplazamiento

    ubicacion = arr + var
    ubicacion = ubicacion[(ubicacion &gt; 0) &amp; (ubicacion &lt; longitud_fibra)]
    self.ubicacion_nodos = ubicacion
    return ubicacion</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="simulacion.FormaDePloteo"><code class="flex name class">
<span>class <span class="ident">FormaDePloteo</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FormaDePloteo(Enum):
    fibras_sin_diametro = &#39;fibras_sin_diametro&#39;
    fibras_con_diametro = &#39;fibras_con_diametro&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="simulacion.FormaDePloteo.fibras_con_diametro"><code class="name">var <span class="ident">fibras_con_diametro</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.FormaDePloteo.fibras_sin_diametro"><code class="name">var <span class="ident">fibras_sin_diametro</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="simulacion.InputError"><code class="flex name class">
<span>class <span class="ident">InputError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InputError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="simulacion.LoadingError"><code class="flex name class">
<span>class <span class="ident">LoadingError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoadingError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="simulacion.MissingParameterError"><code class="flex name class">
<span>class <span class="ident">MissingParameterError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MissingParameterError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="simulacion.Nervio"><code class="flex name class">
<span>class <span class="ident">Nervio</span></span>
<span>(</span><span>diametro, longitud, conductividad_transversal=None, porcentaje_cobertura=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Nervio.</p>
<p>Método constructor de la clase Nervio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>diametro</code></strong> :&ensp;<code>int</code></dt>
<dd>Diametro del nervio en micrómetros.</dd>
<dt><strong><code>longitud</code></strong> :&ensp;<code>int</code></dt>
<dd>Longitud del nervio en micrometros.</dd>
<dt><strong><code>conductividad_transversal</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Conductividad transversal del nervio. Por defecto None.</dd>
<dt><strong><code>porcentaje_cobertura</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Porcentaje del nervio al cual llega el electrodo. Por defecto None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="simulacion.InputError" href="#simulacion.InputError">InputError</a></code></dt>
<dd>Se levanta este error si no se ingresa un valor de conductividad_transversal o de pocentaje_cobertura, dado que uno de los dos es necesario para realizar cálculos posteriores.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Nervio:
    &#34;&#34;&#34;Nervio.
    &#34;&#34;&#34;

    def __init__(self, diametro, longitud, conductividad_transversal=None, porcentaje_cobertura=None):
        &#34;&#34;&#34;Método constructor de la clase Nervio.

        Args:
            diametro (int): Diametro del nervio en micrómetros.
            longitud (int): Longitud del nervio en micrometros.
            conductividad_transversal (float, optional): Conductividad transversal del nervio. Por defecto None.
            porcentaje_cobertura (float, optional): Porcentaje del nervio al cual llega el electrodo. Por defecto None.

        Raises:
            InputError: Se levanta este error si no se ingresa un valor de conductividad_transversal o de pocentaje_cobertura, dado que uno de los dos es necesario para realizar cálculos posteriores.
        &#34;&#34;&#34;
        self.radio = diametro / 2
        self.longitud_nervio = longitud
        self.conductividad_transversal = conductividad_transversal
        self.porcentaje_cobertura = porcentaje_cobertura
        self.fibras = []
        self.cantidad_fibras = 0
        self.limite_lateral_izquierdo = -self.radio
        self.limite_lateral_derecho = self.radio
        self.limite_superior = self.radio
        self.limite_inferior = -self.radio
        self.centro_nervio_x = 0
        self.centro_nervio_y = 0
        self.informacion_nodos = []
        self.metodo_poblacion = None
        self.distancia_nodos_promedio = None

        if self.conductividad_transversal is None and self.porcentaje_cobertura is None:
            raise InputError(
                &#34;Se debe ingresar ya sea un valor de conductividad transversal o un porcentaje de cobertura.&#34;)

    def info_nervio(self):
        &#34;&#34;&#34;Método que devuelve un diccionario con información del nervio.

        Returns:
            dict: Diccionario con información del nervio.
        &#34;&#34;&#34;
        return {
            &#34;diametro&#34;: 2 * self.radio,
            &#34;cantidad_fibras&#34;: self.cantidad_fibras,
            &#34;longitud&#34;: self.longitud_nervio,
            &#34;posicion_centro_nervio&#34;: [self.centro_nervio_x, self.centro_nervio_y],
            &#34;conductividad_transversal&#34;: self.conductividad_transversal,
            &#34;porcentaje_de_cobertura&#34;: self.porcentaje_cobertura
        }

    def informacion_fibras(self):
        &#34;&#34;&#34;Método para obtener una lista con la información de las fibras dentro del nervio.

        Returns:
            numpy.ndarray: Devuelve un array cuyas dos primeras columnas son las coordenadas x e y de cada fibra, y la tercera columna contiene información del diámetro de las fibras.
        &#34;&#34;&#34;
        return np.array([fibra.obtener_info_fibra() for fibra in self.fibras])

    def poblar(self,
               num_fibras,
               diametro_fibra,
               var_diametro,
               metodo_poblacion=&#39;uniforme_con_superposicion&#39;,
               semilla=None,
               alfa=7.6,
               velocidad=None,
               **kwargs):
        &#34;&#34;&#34;Método para poblar el nervio con las fibras nerviosas.

        Args:
            num_fibras (int): Número de fibras que contendrá el nervio.
            diametro_fibra (float): Diámetro de la fibra en micrones.
            var_diametro (int): La variación del diámetro se hace con la función normal, por lo que este es el sigma.
            metodo_poblacion (str, optional): Tipo de método de población de fibras en el nervio. Por defecto es &#39;uniforme&#39;.
            semilla (int, optional): Número de la semilla. Por defecto es None.
            alfa (float, optional): Valor para calcular la velocidad de conducción de las fibras. Por defecto es 7.6. En [m/s/micrómetro]
            velocidad (float,optional): Velocidad de la fibra en [m/s].
        
        Keyword Args:
            array_fibras (numpy.ndarray): Numpy array con 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra, en el método de población manual.
            ubicacion_archivo (str): String con la ubicación del archivo csv para el método de población desde_archivo. El archivo csv debe contener 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra.

        Raises:
            InputError: Si el método de población ingresado no se encuentra entre las opciones disponibles.
        &#34;&#34;&#34;
        self.metodo_poblacion = metodo_poblacion
        if metodo_poblacion == PoblacionNervio.uniforme_con_superposicion.name:
            if diametro_fibra is None:
                raise InputError(&#39;Se debe ingresar un diámetro de fibra.&#39;)
            self.uniforme_con_superposicion(num_fibras=num_fibras,
                                            diametro_fibra=diametro_fibra,
                                            var_diametro=var_diametro,
                                            semilla=semilla,
                                            alfa=alfa,
                                            velocidad=velocidad)
        elif metodo_poblacion == PoblacionNervio.uniforme_sin_superposicion.name:
            if diametro_fibra is None:
                raise InputError(&#39;Se debe ingresar un diámetro de fibra.&#39;)
            self.uniforme_sin_suporsicion(num_fibras=num_fibras,
                                          diametro_fibra=diametro_fibra,
                                          var_diametro=var_diametro,
                                          semilla=semilla,
                                          alfa=alfa,
                                          velocidad=velocidad)
        elif metodo_poblacion == PoblacionNervio.manual.name:
            self.manual(array_fibras=kwargs.get(&#39;array_fibras&#39;, None))
        elif metodo_poblacion == PoblacionNervio.desde_archivo.name:
            self.desde_archivo(ubicacion_archivo=kwargs.get(&#39;ubicacion_archivo&#39;, None))
        else:
            raise InputError(&#39;El método de población ingresado no es correcto.&#39;)

    def uniforme_con_superposicion(self, num_fibras, diametro_fibra, var_diametro, semilla, alfa, velocidad):
        &#34;&#34;&#34;Función para poblar el nervio con distribución uniforme, con superposición de las fibras.

        Args:
            num_fibras (int): Número de fibras que contendrá el nervio.
            diametro_fibra (float): Diámetro de la fibra en micrones.
            var_diametro (int): La variación del diámetro se hace con la función normal, por lo que este es el sigma.
            semilla (int): Número de la semilla.
            alfa (float): Valor para calcular la velocidad de conducción de las fibras.
            velocidad (float): Velocidad de la fibra en [m/s].
        &#34;&#34;&#34;
        #Tiene centro en (0,0), implementar el traslado
        np.random.seed(semilla)
        longitud = np.random.uniform(0, self.radio**2, size=num_fibras)
        angulo = np.pi * np.random.uniform(0, 2, size=num_fibras)
        diam = []
        while len(diam) &lt; num_fibras:
            diametro = np.random.normal(diametro_fibra, var_diametro)
            if diametro &gt; 0:
                diam.append(diametro)
        x = np.sqrt(longitud) * np.cos(angulo)
        y = np.sqrt(longitud) * np.sin(angulo)
        matriz = np.column_stack((x, y, np.array(diam)))
        self.fibras = [
            Fibra(x=x, y=y, diametro=diam, velocidad=alfa *
                  diam) if velocidad is None else Fibra(x=x, y=y, diametro=diam, velocidad=velocidad)
            for x, y, diam in matriz
        ]
        self.cantidad_fibras = num_fibras

    def uniforme_sin_suporsicion(self, num_fibras, diametro_fibra, var_diametro, semilla, alfa, velocidad):
        &#34;&#34;&#34;Función para poblar el nervio con distribución uniforme, sin superposición de las fibras.

        Args:
            num_fibras (int): Número de fibras que contendrá el nervio.
            diametro_fibra (float): Diámetro de la fibra en micrones.
            var_diametro (int): La variación del diámetro se hace con la función normal, por lo que este es el sigma.
            semilla (int): Número de la semilla.
            alfa (float): Valor para calcular la velocidad de conducción de las fibras.
            velocidad (float): Velocidad de la fibra en [m/s].
        &#34;&#34;&#34;
        np.random.seed(semilla)
        lista = []

        while len(lista) &lt; num_fibras:
            choque = False
            length = np.random.uniform(0, self.radio**2)
            angle = np.pi * np.random.uniform(0, 2)
            diam = np.random.normal(diametro_fibra, var_diametro)
            while diam &lt;= 0:
                diam = np.random.normal(diametro_fibra, var_diametro)
            x = np.sqrt(length) * np.cos(angle)
            y = np.sqrt(length) * np.sin(angle)

            for a, b, c in lista:
                if distancia_entre_circulos(x, y, diam / 2, a, b, c / 2) &lt; 0:
                    choque = True
            if choque is False and is_inside_circencirc(diam / 2, x, y, self.radio, self.centro_nervio_x,
                                                        self.centro_nervio_y):
                lista.append([x, y, diam])

        self.fibras = [
            Fibra(x=x, y=y, diametro=diam, velocidad=alfa *
                  diam) if velocidad is None else Fibra(x=x, y=y, diametro=diam, velocidad=velocidad)
            for x, y, diam in lista
        ]
        self.cantidad_fibras = num_fibras

    def manual(self, array_fibras):
        &#34;&#34;&#34;Función para poblar el nervio de forma manual, a partir de un array con la posición de las fibras, y sus diámetros.

        Args:
            array_fibras (numpy.ndarray): Array con la posición y diámetros de las fibras, si lo tuviera.
            
        Raises:
            ValueError: Valor que se levanta cuando se encuentra que en el array ingresado no se encuentran todos los parámetros necesarios.
            OutOfBounds: Error que se levanta si se encuentra que alguna de las fibras ingresadas supera los límites del nervio.
        &#34;&#34;&#34;
        try:
            f = [
                Fibra(x, y, d, v)
                for x, y, d, v in array_fibras
                if is_inside_circencirc(d / 2, x, y, self.radio, self.centro_nervio_x, self.centro_nervio_y)
            ]
        except ValueError as exc:
            raise ValueError(
                &#39;Se necesitan los datos de ubicación de fibras en eje x e y, diámetros y velocidades para este método.&#39;
            ) from exc

        if len(f) != len(array_fibras):
            raise OutOfBounds(&#34;Se encontró por lo menos una fibra fuera de los límites del nervio.&#34;)

        self.fibras = f
        self.cantidad_fibras = len(array_fibras)

    def desde_archivo(self, ubicacion_archivo):
        &#34;&#34;&#34;Función para poblar un nervio, a partir de un archivo csv.

        Args:
            ubicacion_archivo (str): String con la ubicación del archivo csv.
            
        Raises:
            LoadingError: Error que se levanta cuando no se puede cargar el archivo.
            ValueError: Error que se levanta cuando se detecta que algún caracter ingresado en el archivo no es numérico.
        &#34;&#34;&#34;
        try:
            fibras = np.genfromtxt(ubicacion_archivo, delimiter=&#39;,&#39;)
        except Exception as e:
            raise LoadingError(&#39;Fallo en carga de archivo.&#39;) from e

        if not np.isnan(sum(fibras)).any() and np.issubdtype(fibras.dtype, np.number):
            self.manual(array_fibras=fibras)
        else:
            raise ValueError(&#34;La lista contiene caracteres que no son números.&#34;)

    def ploteo_fibras_puntos(self, borde_nervio=&#39;blue&#39;, relleno_nervio=&#39;None&#39;, color_fibras=&#39;red&#39;):
        &#34;&#34;&#34;Método para graficar una vista transversal del nervio. Las fibras se muestran como puntos (sin diámetro real).

        Args:
            borde_nervio (str, optional): Color del borde del nervio. Por defecto es azul (&#39;blue&#39;).
            relleno_nervio (str, optional): Color del relleno del nervio. Por defecto no tiene color (&#39;None&#39;).
            color_fibras (str, optional): Color de las fibras, graficadas como puntos. Escribirlo según formato aceptable por Matplotlib. Por defecto es rojo (&#39;r&#39;).
        &#34;&#34;&#34;

        #Ploteo de las fibras
        matriz = self.informacion_fibras()
        plt.plot(matriz[:, 0], matriz[:, 1], label=&#39;Fibras&#39;, color=color_fibras, marker=&#39;.&#39;, linestyle=&#39;None&#39;)

        #Ploteo del nervio
        plt.gca().add_patch(
            plt.Circle((0, 0), self.radio, edgecolor=borde_nervio, facecolor=relleno_nervio, label=&#39;Nervio&#39;))

    def ploteo_fibras_circulos(self,
                               borde_nervio=&#39;blue&#39;,
                               relleno_nervio=&#39;None&#39;,
                               borde_fibras=&#39;red&#39;,
                               relleno_fibras=&#39;None&#39;):
        &#34;&#34;&#34;Método para graficar una vista transversal del nervio. Las fibras se muestran como círculos, con su respectivo diámetro.

        Args:
            borde_nervio (str, optional): Color del borde del nervio. Por defecto es azul (&#39;blue&#39;).
            relleno_nervio (str, optional): Color del relleno del nervio. Por defecto no tiene color (&#39;None&#39;).
            borde_fibras (str, optional): Color del borde de las fibras. Por defecto es rojo (&#39;red&#39;).
            relleno_fibras (str, optional): Color del relleno de las fibras. Por defecto no tiene color (&#39;None&#39;).

        Raises:
            InputError: Cuando se encuentra por lo menos una fibra con diámetro igual a 0.
        &#34;&#34;&#34;
        matriz = self.informacion_fibras()
        if matriz[:, 2].any() == 0:
            raise InputError(&#34;Por lo menos una fibra tiene diámetro igual a 0.&#34;)

        #Ploteo de las fibras
        for i in range(len(matriz)):
            circle = plt.Circle((matriz[i, 0], matriz[i, 1]),
                                matriz[i, 2],
                                edgecolor=borde_fibras,
                                facecolor=relleno_fibras,
                                label=&#34;Fibras&#34; if i == 0 else &#34;&#34;)
            plt.gca().add_patch(circle)

        #Ploteo del nervio
        plt.gca().add_patch(
            plt.Circle((0, 0), self.radio, edgecolor=borde_nervio, facecolor=relleno_nervio, label=&#39;Nervio&#39;))

    def agregar_nodos(self, distancia_nodos, variacion_nodos, desplazamiento, distribucion_variacion=&#39;uniforme&#39;):
        &#34;&#34;&#34;Método que permite agregar nodos a las fibras. 

        Args:
            distancia_nodos (float): Distancia entre nodos en las fibras en micrómetros.
            variacion (float): Variación de la distancia entre nodos en micrómetros.
            desplazamiento (float): Desplazamiento de los nodos en micrómetros. 
            distribucion_variacion (str, optional): Distribución de la variación de la distancia entre nodos. Se espera un valor correspondiente a alguna de las opciones de VariacionNodos. Por defecto es &#39;uniforme&#39;.
        &#34;&#34;&#34;
        self.distancia_nodos_promedio = distancia_nodos
        self.informacion_nodos = [
            f.ubicar_nodos(distancia_nodos=distancia_nodos,
                           variacion=variacion_nodos,
                           desplazamiento=np.random.uniform(-desplazamiento, desplazamiento),
                           distribucion_variacion=distribucion_variacion,
                           longitud_fibra=self.longitud_nervio) for f in self.fibras
        ]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="simulacion.Nervio.agregar_nodos"><code class="name flex">
<span>def <span class="ident">agregar_nodos</span></span>(<span>self, distancia_nodos, variacion_nodos, desplazamiento, distribucion_variacion='uniforme')</span>
</code></dt>
<dd>
<div class="desc"><p>Método que permite agregar nodos a las fibras. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>distancia_nodos</code></strong> :&ensp;<code>float</code></dt>
<dd>Distancia entre nodos en las fibras en micrómetros.</dd>
<dt><strong><code>variacion</code></strong> :&ensp;<code>float</code></dt>
<dd>Variación de la distancia entre nodos en micrómetros.</dd>
<dt><strong><code>desplazamiento</code></strong> :&ensp;<code>float</code></dt>
<dd>Desplazamiento de los nodos en micrómetros. </dd>
<dt><strong><code>distribucion_variacion</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Distribución de la variación de la distancia entre nodos. Se espera un valor correspondiente a alguna de las opciones de VariacionNodos. Por defecto es 'uniforme'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def agregar_nodos(self, distancia_nodos, variacion_nodos, desplazamiento, distribucion_variacion=&#39;uniforme&#39;):
    &#34;&#34;&#34;Método que permite agregar nodos a las fibras. 

    Args:
        distancia_nodos (float): Distancia entre nodos en las fibras en micrómetros.
        variacion (float): Variación de la distancia entre nodos en micrómetros.
        desplazamiento (float): Desplazamiento de los nodos en micrómetros. 
        distribucion_variacion (str, optional): Distribución de la variación de la distancia entre nodos. Se espera un valor correspondiente a alguna de las opciones de VariacionNodos. Por defecto es &#39;uniforme&#39;.
    &#34;&#34;&#34;
    self.distancia_nodos_promedio = distancia_nodos
    self.informacion_nodos = [
        f.ubicar_nodos(distancia_nodos=distancia_nodos,
                       variacion=variacion_nodos,
                       desplazamiento=np.random.uniform(-desplazamiento, desplazamiento),
                       distribucion_variacion=distribucion_variacion,
                       longitud_fibra=self.longitud_nervio) for f in self.fibras
    ]</code></pre>
</details>
</dd>
<dt id="simulacion.Nervio.desde_archivo"><code class="name flex">
<span>def <span class="ident">desde_archivo</span></span>(<span>self, ubicacion_archivo)</span>
</code></dt>
<dd>
<div class="desc"><p>Función para poblar un nervio, a partir de un archivo csv.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ubicacion_archivo</code></strong> :&ensp;<code>str</code></dt>
<dd>String con la ubicación del archivo csv.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="simulacion.LoadingError" href="#simulacion.LoadingError">LoadingError</a></code></dt>
<dd>Error que se levanta cuando no se puede cargar el archivo.</dd>
<dt><code>ValueError</code></dt>
<dd>Error que se levanta cuando se detecta que algún caracter ingresado en el archivo no es numérico.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def desde_archivo(self, ubicacion_archivo):
    &#34;&#34;&#34;Función para poblar un nervio, a partir de un archivo csv.

    Args:
        ubicacion_archivo (str): String con la ubicación del archivo csv.
        
    Raises:
        LoadingError: Error que se levanta cuando no se puede cargar el archivo.
        ValueError: Error que se levanta cuando se detecta que algún caracter ingresado en el archivo no es numérico.
    &#34;&#34;&#34;
    try:
        fibras = np.genfromtxt(ubicacion_archivo, delimiter=&#39;,&#39;)
    except Exception as e:
        raise LoadingError(&#39;Fallo en carga de archivo.&#39;) from e

    if not np.isnan(sum(fibras)).any() and np.issubdtype(fibras.dtype, np.number):
        self.manual(array_fibras=fibras)
    else:
        raise ValueError(&#34;La lista contiene caracteres que no son números.&#34;)</code></pre>
</details>
</dd>
<dt id="simulacion.Nervio.info_nervio"><code class="name flex">
<span>def <span class="ident">info_nervio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Método que devuelve un diccionario con información del nervio.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Diccionario con información del nervio.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info_nervio(self):
    &#34;&#34;&#34;Método que devuelve un diccionario con información del nervio.

    Returns:
        dict: Diccionario con información del nervio.
    &#34;&#34;&#34;
    return {
        &#34;diametro&#34;: 2 * self.radio,
        &#34;cantidad_fibras&#34;: self.cantidad_fibras,
        &#34;longitud&#34;: self.longitud_nervio,
        &#34;posicion_centro_nervio&#34;: [self.centro_nervio_x, self.centro_nervio_y],
        &#34;conductividad_transversal&#34;: self.conductividad_transversal,
        &#34;porcentaje_de_cobertura&#34;: self.porcentaje_cobertura
    }</code></pre>
</details>
</dd>
<dt id="simulacion.Nervio.informacion_fibras"><code class="name flex">
<span>def <span class="ident">informacion_fibras</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para obtener una lista con la información de las fibras dentro del nervio.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Devuelve un array cuyas dos primeras columnas son las coordenadas x e y de cada fibra, y la tercera columna contiene información del diámetro de las fibras.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def informacion_fibras(self):
    &#34;&#34;&#34;Método para obtener una lista con la información de las fibras dentro del nervio.

    Returns:
        numpy.ndarray: Devuelve un array cuyas dos primeras columnas son las coordenadas x e y de cada fibra, y la tercera columna contiene información del diámetro de las fibras.
    &#34;&#34;&#34;
    return np.array([fibra.obtener_info_fibra() for fibra in self.fibras])</code></pre>
</details>
</dd>
<dt id="simulacion.Nervio.manual"><code class="name flex">
<span>def <span class="ident">manual</span></span>(<span>self, array_fibras)</span>
</code></dt>
<dd>
<div class="desc"><p>Función para poblar el nervio de forma manual, a partir de un array con la posición de las fibras, y sus diámetros.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array_fibras</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array con la posición y diámetros de las fibras, si lo tuviera.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Valor que se levanta cuando se encuentra que en el array ingresado no se encuentran todos los parámetros necesarios.</dd>
<dt><code><a title="simulacion.OutOfBounds" href="#simulacion.OutOfBounds">OutOfBounds</a></code></dt>
<dd>Error que se levanta si se encuentra que alguna de las fibras ingresadas supera los límites del nervio.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manual(self, array_fibras):
    &#34;&#34;&#34;Función para poblar el nervio de forma manual, a partir de un array con la posición de las fibras, y sus diámetros.

    Args:
        array_fibras (numpy.ndarray): Array con la posición y diámetros de las fibras, si lo tuviera.
        
    Raises:
        ValueError: Valor que se levanta cuando se encuentra que en el array ingresado no se encuentran todos los parámetros necesarios.
        OutOfBounds: Error que se levanta si se encuentra que alguna de las fibras ingresadas supera los límites del nervio.
    &#34;&#34;&#34;
    try:
        f = [
            Fibra(x, y, d, v)
            for x, y, d, v in array_fibras
            if is_inside_circencirc(d / 2, x, y, self.radio, self.centro_nervio_x, self.centro_nervio_y)
        ]
    except ValueError as exc:
        raise ValueError(
            &#39;Se necesitan los datos de ubicación de fibras en eje x e y, diámetros y velocidades para este método.&#39;
        ) from exc

    if len(f) != len(array_fibras):
        raise OutOfBounds(&#34;Se encontró por lo menos una fibra fuera de los límites del nervio.&#34;)

    self.fibras = f
    self.cantidad_fibras = len(array_fibras)</code></pre>
</details>
</dd>
<dt id="simulacion.Nervio.ploteo_fibras_circulos"><code class="name flex">
<span>def <span class="ident">ploteo_fibras_circulos</span></span>(<span>self, borde_nervio='blue', relleno_nervio='None', borde_fibras='red', relleno_fibras='None')</span>
</code></dt>
<dd>
<div class="desc"><p>Método para graficar una vista transversal del nervio. Las fibras se muestran como círculos, con su respectivo diámetro.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>borde_nervio</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color del borde del nervio. Por defecto es azul ('blue').</dd>
<dt><strong><code>relleno_nervio</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color del relleno del nervio. Por defecto no tiene color ('None').</dd>
<dt><strong><code>borde_fibras</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color del borde de las fibras. Por defecto es rojo ('red').</dd>
<dt><strong><code>relleno_fibras</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color del relleno de las fibras. Por defecto no tiene color ('None').</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="simulacion.InputError" href="#simulacion.InputError">InputError</a></code></dt>
<dd>Cuando se encuentra por lo menos una fibra con diámetro igual a 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ploteo_fibras_circulos(self,
                           borde_nervio=&#39;blue&#39;,
                           relleno_nervio=&#39;None&#39;,
                           borde_fibras=&#39;red&#39;,
                           relleno_fibras=&#39;None&#39;):
    &#34;&#34;&#34;Método para graficar una vista transversal del nervio. Las fibras se muestran como círculos, con su respectivo diámetro.

    Args:
        borde_nervio (str, optional): Color del borde del nervio. Por defecto es azul (&#39;blue&#39;).
        relleno_nervio (str, optional): Color del relleno del nervio. Por defecto no tiene color (&#39;None&#39;).
        borde_fibras (str, optional): Color del borde de las fibras. Por defecto es rojo (&#39;red&#39;).
        relleno_fibras (str, optional): Color del relleno de las fibras. Por defecto no tiene color (&#39;None&#39;).

    Raises:
        InputError: Cuando se encuentra por lo menos una fibra con diámetro igual a 0.
    &#34;&#34;&#34;
    matriz = self.informacion_fibras()
    if matriz[:, 2].any() == 0:
        raise InputError(&#34;Por lo menos una fibra tiene diámetro igual a 0.&#34;)

    #Ploteo de las fibras
    for i in range(len(matriz)):
        circle = plt.Circle((matriz[i, 0], matriz[i, 1]),
                            matriz[i, 2],
                            edgecolor=borde_fibras,
                            facecolor=relleno_fibras,
                            label=&#34;Fibras&#34; if i == 0 else &#34;&#34;)
        plt.gca().add_patch(circle)

    #Ploteo del nervio
    plt.gca().add_patch(
        plt.Circle((0, 0), self.radio, edgecolor=borde_nervio, facecolor=relleno_nervio, label=&#39;Nervio&#39;))</code></pre>
</details>
</dd>
<dt id="simulacion.Nervio.ploteo_fibras_puntos"><code class="name flex">
<span>def <span class="ident">ploteo_fibras_puntos</span></span>(<span>self, borde_nervio='blue', relleno_nervio='None', color_fibras='red')</span>
</code></dt>
<dd>
<div class="desc"><p>Método para graficar una vista transversal del nervio. Las fibras se muestran como puntos (sin diámetro real).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>borde_nervio</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color del borde del nervio. Por defecto es azul ('blue').</dd>
<dt><strong><code>relleno_nervio</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color del relleno del nervio. Por defecto no tiene color ('None').</dd>
<dt><strong><code>color_fibras</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color de las fibras, graficadas como puntos. Escribirlo según formato aceptable por Matplotlib. Por defecto es rojo ('r').</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ploteo_fibras_puntos(self, borde_nervio=&#39;blue&#39;, relleno_nervio=&#39;None&#39;, color_fibras=&#39;red&#39;):
    &#34;&#34;&#34;Método para graficar una vista transversal del nervio. Las fibras se muestran como puntos (sin diámetro real).

    Args:
        borde_nervio (str, optional): Color del borde del nervio. Por defecto es azul (&#39;blue&#39;).
        relleno_nervio (str, optional): Color del relleno del nervio. Por defecto no tiene color (&#39;None&#39;).
        color_fibras (str, optional): Color de las fibras, graficadas como puntos. Escribirlo según formato aceptable por Matplotlib. Por defecto es rojo (&#39;r&#39;).
    &#34;&#34;&#34;

    #Ploteo de las fibras
    matriz = self.informacion_fibras()
    plt.plot(matriz[:, 0], matriz[:, 1], label=&#39;Fibras&#39;, color=color_fibras, marker=&#39;.&#39;, linestyle=&#39;None&#39;)

    #Ploteo del nervio
    plt.gca().add_patch(
        plt.Circle((0, 0), self.radio, edgecolor=borde_nervio, facecolor=relleno_nervio, label=&#39;Nervio&#39;))</code></pre>
</details>
</dd>
<dt id="simulacion.Nervio.poblar"><code class="name flex">
<span>def <span class="ident">poblar</span></span>(<span>self, num_fibras, diametro_fibra, var_diametro, metodo_poblacion='uniforme_con_superposicion', semilla=None, alfa=7.6, velocidad=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Método para poblar el nervio con las fibras nerviosas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_fibras</code></strong> :&ensp;<code>int</code></dt>
<dd>Número de fibras que contendrá el nervio.</dd>
<dt><strong><code>diametro_fibra</code></strong> :&ensp;<code>float</code></dt>
<dd>Diámetro de la fibra en micrones.</dd>
<dt><strong><code>var_diametro</code></strong> :&ensp;<code>int</code></dt>
<dd>La variación del diámetro se hace con la función normal, por lo que este es el sigma.</dd>
<dt><strong><code>metodo_poblacion</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Tipo de método de población de fibras en el nervio. Por defecto es 'uniforme'.</dd>
<dt><strong><code>semilla</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Número de la semilla. Por defecto es None.</dd>
<dt><strong><code>alfa</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Valor para calcular la velocidad de conducción de las fibras. Por defecto es 7.6. En [m/s/micrómetro]</dd>
<dt><strong><code>velocidad</code></strong> :&ensp;<code>float</code>,optional</dt>
<dd>Velocidad de la fibra en [m/s].</dd>
</dl>

<h2 id="args">Keyword Args</h2>
<dl>
<dt><strong><code>array_fibras</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Numpy array con 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra, en el método de población manual.</dd>
<dt><strong><code>ubicacion_archivo</code></strong> :&ensp;<code>str</code></dt>
<dd>String con la ubicación del archivo csv para el método de población desde_archivo. El archivo csv debe contener 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra.</dd>
</dl>

<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="simulacion.InputError" href="#simulacion.InputError">InputError</a></code></dt>
<dd>Si el método de población ingresado no se encuentra entre las opciones disponibles.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poblar(self,
           num_fibras,
           diametro_fibra,
           var_diametro,
           metodo_poblacion=&#39;uniforme_con_superposicion&#39;,
           semilla=None,
           alfa=7.6,
           velocidad=None,
           **kwargs):
    &#34;&#34;&#34;Método para poblar el nervio con las fibras nerviosas.

    Args:
        num_fibras (int): Número de fibras que contendrá el nervio.
        diametro_fibra (float): Diámetro de la fibra en micrones.
        var_diametro (int): La variación del diámetro se hace con la función normal, por lo que este es el sigma.
        metodo_poblacion (str, optional): Tipo de método de población de fibras en el nervio. Por defecto es &#39;uniforme&#39;.
        semilla (int, optional): Número de la semilla. Por defecto es None.
        alfa (float, optional): Valor para calcular la velocidad de conducción de las fibras. Por defecto es 7.6. En [m/s/micrómetro]
        velocidad (float,optional): Velocidad de la fibra en [m/s].
    
    Keyword Args:
        array_fibras (numpy.ndarray): Numpy array con 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra, en el método de población manual.
        ubicacion_archivo (str): String con la ubicación del archivo csv para el método de población desde_archivo. El archivo csv debe contener 4 columnas: posición x, posición y, diámetro y velocidad de cada fibra.

    Raises:
        InputError: Si el método de población ingresado no se encuentra entre las opciones disponibles.
    &#34;&#34;&#34;
    self.metodo_poblacion = metodo_poblacion
    if metodo_poblacion == PoblacionNervio.uniforme_con_superposicion.name:
        if diametro_fibra is None:
            raise InputError(&#39;Se debe ingresar un diámetro de fibra.&#39;)
        self.uniforme_con_superposicion(num_fibras=num_fibras,
                                        diametro_fibra=diametro_fibra,
                                        var_diametro=var_diametro,
                                        semilla=semilla,
                                        alfa=alfa,
                                        velocidad=velocidad)
    elif metodo_poblacion == PoblacionNervio.uniforme_sin_superposicion.name:
        if diametro_fibra is None:
            raise InputError(&#39;Se debe ingresar un diámetro de fibra.&#39;)
        self.uniforme_sin_suporsicion(num_fibras=num_fibras,
                                      diametro_fibra=diametro_fibra,
                                      var_diametro=var_diametro,
                                      semilla=semilla,
                                      alfa=alfa,
                                      velocidad=velocidad)
    elif metodo_poblacion == PoblacionNervio.manual.name:
        self.manual(array_fibras=kwargs.get(&#39;array_fibras&#39;, None))
    elif metodo_poblacion == PoblacionNervio.desde_archivo.name:
        self.desde_archivo(ubicacion_archivo=kwargs.get(&#39;ubicacion_archivo&#39;, None))
    else:
        raise InputError(&#39;El método de población ingresado no es correcto.&#39;)</code></pre>
</details>
</dd>
<dt id="simulacion.Nervio.uniforme_con_superposicion"><code class="name flex">
<span>def <span class="ident">uniforme_con_superposicion</span></span>(<span>self, num_fibras, diametro_fibra, var_diametro, semilla, alfa, velocidad)</span>
</code></dt>
<dd>
<div class="desc"><p>Función para poblar el nervio con distribución uniforme, con superposición de las fibras.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_fibras</code></strong> :&ensp;<code>int</code></dt>
<dd>Número de fibras que contendrá el nervio.</dd>
<dt><strong><code>diametro_fibra</code></strong> :&ensp;<code>float</code></dt>
<dd>Diámetro de la fibra en micrones.</dd>
<dt><strong><code>var_diametro</code></strong> :&ensp;<code>int</code></dt>
<dd>La variación del diámetro se hace con la función normal, por lo que este es el sigma.</dd>
<dt><strong><code>semilla</code></strong> :&ensp;<code>int</code></dt>
<dd>Número de la semilla.</dd>
<dt><strong><code>alfa</code></strong> :&ensp;<code>float</code></dt>
<dd>Valor para calcular la velocidad de conducción de las fibras.</dd>
<dt><strong><code>velocidad</code></strong> :&ensp;<code>float</code></dt>
<dd>Velocidad de la fibra en [m/s].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniforme_con_superposicion(self, num_fibras, diametro_fibra, var_diametro, semilla, alfa, velocidad):
    &#34;&#34;&#34;Función para poblar el nervio con distribución uniforme, con superposición de las fibras.

    Args:
        num_fibras (int): Número de fibras que contendrá el nervio.
        diametro_fibra (float): Diámetro de la fibra en micrones.
        var_diametro (int): La variación del diámetro se hace con la función normal, por lo que este es el sigma.
        semilla (int): Número de la semilla.
        alfa (float): Valor para calcular la velocidad de conducción de las fibras.
        velocidad (float): Velocidad de la fibra en [m/s].
    &#34;&#34;&#34;
    #Tiene centro en (0,0), implementar el traslado
    np.random.seed(semilla)
    longitud = np.random.uniform(0, self.radio**2, size=num_fibras)
    angulo = np.pi * np.random.uniform(0, 2, size=num_fibras)
    diam = []
    while len(diam) &lt; num_fibras:
        diametro = np.random.normal(diametro_fibra, var_diametro)
        if diametro &gt; 0:
            diam.append(diametro)
    x = np.sqrt(longitud) * np.cos(angulo)
    y = np.sqrt(longitud) * np.sin(angulo)
    matriz = np.column_stack((x, y, np.array(diam)))
    self.fibras = [
        Fibra(x=x, y=y, diametro=diam, velocidad=alfa *
              diam) if velocidad is None else Fibra(x=x, y=y, diametro=diam, velocidad=velocidad)
        for x, y, diam in matriz
    ]
    self.cantidad_fibras = num_fibras</code></pre>
</details>
</dd>
<dt id="simulacion.Nervio.uniforme_sin_suporsicion"><code class="name flex">
<span>def <span class="ident">uniforme_sin_suporsicion</span></span>(<span>self, num_fibras, diametro_fibra, var_diametro, semilla, alfa, velocidad)</span>
</code></dt>
<dd>
<div class="desc"><p>Función para poblar el nervio con distribución uniforme, sin superposición de las fibras.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_fibras</code></strong> :&ensp;<code>int</code></dt>
<dd>Número de fibras que contendrá el nervio.</dd>
<dt><strong><code>diametro_fibra</code></strong> :&ensp;<code>float</code></dt>
<dd>Diámetro de la fibra en micrones.</dd>
<dt><strong><code>var_diametro</code></strong> :&ensp;<code>int</code></dt>
<dd>La variación del diámetro se hace con la función normal, por lo que este es el sigma.</dd>
<dt><strong><code>semilla</code></strong> :&ensp;<code>int</code></dt>
<dd>Número de la semilla.</dd>
<dt><strong><code>alfa</code></strong> :&ensp;<code>float</code></dt>
<dd>Valor para calcular la velocidad de conducción de las fibras.</dd>
<dt><strong><code>velocidad</code></strong> :&ensp;<code>float</code></dt>
<dd>Velocidad de la fibra en [m/s].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniforme_sin_suporsicion(self, num_fibras, diametro_fibra, var_diametro, semilla, alfa, velocidad):
    &#34;&#34;&#34;Función para poblar el nervio con distribución uniforme, sin superposición de las fibras.

    Args:
        num_fibras (int): Número de fibras que contendrá el nervio.
        diametro_fibra (float): Diámetro de la fibra en micrones.
        var_diametro (int): La variación del diámetro se hace con la función normal, por lo que este es el sigma.
        semilla (int): Número de la semilla.
        alfa (float): Valor para calcular la velocidad de conducción de las fibras.
        velocidad (float): Velocidad de la fibra en [m/s].
    &#34;&#34;&#34;
    np.random.seed(semilla)
    lista = []

    while len(lista) &lt; num_fibras:
        choque = False
        length = np.random.uniform(0, self.radio**2)
        angle = np.pi * np.random.uniform(0, 2)
        diam = np.random.normal(diametro_fibra, var_diametro)
        while diam &lt;= 0:
            diam = np.random.normal(diametro_fibra, var_diametro)
        x = np.sqrt(length) * np.cos(angle)
        y = np.sqrt(length) * np.sin(angle)

        for a, b, c in lista:
            if distancia_entre_circulos(x, y, diam / 2, a, b, c / 2) &lt; 0:
                choque = True
        if choque is False and is_inside_circencirc(diam / 2, x, y, self.radio, self.centro_nervio_x,
                                                    self.centro_nervio_y):
            lista.append([x, y, diam])

    self.fibras = [
        Fibra(x=x, y=y, diametro=diam, velocidad=alfa *
              diam) if velocidad is None else Fibra(x=x, y=y, diametro=diam, velocidad=velocidad)
        for x, y, diam in lista
    ]
    self.cantidad_fibras = num_fibras</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="simulacion.ObjectCreationError"><code class="flex name class">
<span>class <span class="ident">ObjectCreationError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ObjectCreationError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="simulacion.OutOfBounds"><code class="flex name class">
<span>class <span class="ident">OutOfBounds</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutOfBounds(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="simulacion.PoblacionNervio"><code class="flex name class">
<span>class <span class="ident">PoblacionNervio</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PoblacionNervio(Enum):
    uniforme_con_superposicion = &#39;uniforme_con_superposicion&#39;
    uniforme_sin_superposicion = &#39;uniforme_sin_superposicion&#39;
    manual = &#39;manual&#39;
    desde_archivo = &#39;desde_archivo&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="simulacion.PoblacionNervio.desde_archivo"><code class="name">var <span class="ident">desde_archivo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.PoblacionNervio.manual"><code class="name">var <span class="ident">manual</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.PoblacionNervio.uniforme_con_superposicion"><code class="name">var <span class="ident">uniforme_con_superposicion</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.PoblacionNervio.uniforme_sin_superposicion"><code class="name">var <span class="ident">uniforme_sin_superposicion</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="simulacion.TipoElectrodo"><code class="flex name class">
<span>class <span class="ident">TipoElectrodo</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TipoElectrodo(Enum):
    punto = &#39;punto&#39;
    circulo = &#39;circulo&#39;
    poligono = &#39;poligono&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="simulacion.TipoElectrodo.circulo"><code class="name">var <span class="ident">circulo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.TipoElectrodo.poligono"><code class="name">var <span class="ident">poligono</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.TipoElectrodo.punto"><code class="name">var <span class="ident">punto</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="simulacion.TipoEstimulo"><code class="flex name class">
<span>class <span class="ident">TipoEstimulo</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TipoEstimulo(Enum):
    potencial_de_accion = &#39;potencial_de_accion&#39;
    cuadrado = &#39;cuadrado&#39;
    manual = &#39;manual&#39;
    desde_archivo = &#39;desde_archivo&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="simulacion.TipoEstimulo.cuadrado"><code class="name">var <span class="ident">cuadrado</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.TipoEstimulo.desde_archivo"><code class="name">var <span class="ident">desde_archivo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.TipoEstimulo.manual"><code class="name">var <span class="ident">manual</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.TipoEstimulo.potencial_de_accion"><code class="name">var <span class="ident">potencial_de_accion</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="simulacion.TipoFibra"><code class="flex name class">
<span>class <span class="ident">TipoFibra</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TipoFibra(Enum):
    puntual = &#39;puntual&#39;
    no_puntual = &#39;no_puntual&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="simulacion.TipoFibra.no_puntual"><code class="name">var <span class="ident">no_puntual</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.TipoFibra.puntual"><code class="name">var <span class="ident">puntual</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="simulacion.VariacionNodos"><code class="flex name class">
<span>class <span class="ident">VariacionNodos</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariacionNodos(Enum):
    uniforme = &#39;uniforme&#39;
    normal = &#39;normal&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="simulacion.VariacionNodos.normal"><code class="name">var <span class="ident">normal</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulacion.VariacionNodos.uniforme"><code class="name">var <span class="ident">uniforme</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="simulacion.array_to_multiarray" href="#simulacion.array_to_multiarray">array_to_multiarray</a></code></li>
<li><code><a title="simulacion.distancia_entre_circulos" href="#simulacion.distancia_entre_circulos">distancia_entre_circulos</a></code></li>
<li><code><a title="simulacion.distancia_entre_puntos" href="#simulacion.distancia_entre_puntos">distancia_entre_puntos</a></code></li>
<li><code><a title="simulacion.funcion_constante" href="#simulacion.funcion_constante">funcion_constante</a></code></li>
<li><code><a title="simulacion.funcion_gaussiana" href="#simulacion.funcion_gaussiana">funcion_gaussiana</a></code></li>
<li><code><a title="simulacion.funcion_trapecio" href="#simulacion.funcion_trapecio">funcion_trapecio</a></code></li>
<li><code><a title="simulacion.insertar_estimulo" href="#simulacion.insertar_estimulo">insertar_estimulo</a></code></li>
<li><code><a title="simulacion.is_inside_circencirc" href="#simulacion.is_inside_circencirc">is_inside_circencirc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="simulacion.Electrodo" href="#simulacion.Electrodo">Electrodo</a></code></h4>
<ul class="two-column">
<li><code><a title="simulacion.Electrodo.calcular_distancias" href="#simulacion.Electrodo.calcular_distancias">calcular_distancias</a></code></li>
<li><code><a title="simulacion.Electrodo.calcular_pesos" href="#simulacion.Electrodo.calcular_pesos">calcular_pesos</a></code></li>
<li><code><a title="simulacion.Electrodo.calcular_wlong" href="#simulacion.Electrodo.calcular_wlong">calcular_wlong</a></code></li>
<li><code><a title="simulacion.Electrodo.calcular_wmax" href="#simulacion.Electrodo.calcular_wmax">calcular_wmax</a></code></li>
<li><code><a title="simulacion.Electrodo.cap_funcion" href="#simulacion.Electrodo.cap_funcion">cap_funcion</a></code></li>
<li><code><a title="simulacion.Electrodo.info_electrodo" href="#simulacion.Electrodo.info_electrodo">info_electrodo</a></code></li>
<li><code><a title="simulacion.Electrodo.ploteo_electrodo" href="#simulacion.Electrodo.ploteo_electrodo">ploteo_electrodo</a></code></li>
<li><code><a title="simulacion.Electrodo.sfap_funcion" href="#simulacion.Electrodo.sfap_funcion">sfap_funcion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulacion.Entorno" href="#simulacion.Entorno">Entorno</a></code></h4>
<ul class="two-column">
<li><code><a title="simulacion.Entorno.archivo_matlab" href="#simulacion.Entorno.archivo_matlab">archivo_matlab</a></code></li>
<li><code><a title="simulacion.Entorno.cap" href="#simulacion.Entorno.cap">cap</a></code></li>
<li><code><a title="simulacion.Entorno.cap_diferencial" href="#simulacion.Entorno.cap_diferencial">cap_diferencial</a></code></li>
<li><code><a title="simulacion.Entorno.crear_electrodo" href="#simulacion.Entorno.crear_electrodo">crear_electrodo</a></code></li>
<li><code><a title="simulacion.Entorno.crear_estimulo" href="#simulacion.Entorno.crear_estimulo">crear_estimulo</a></code></li>
<li><code><a title="simulacion.Entorno.crear_nervio" href="#simulacion.Entorno.crear_nervio">crear_nervio</a></code></li>
<li><code><a title="simulacion.Entorno.dibujar_entorno" href="#simulacion.Entorno.dibujar_entorno">dibujar_entorno</a></code></li>
<li><code><a title="simulacion.Entorno.graficas" href="#simulacion.Entorno.graficas">graficas</a></code></li>
<li><code><a title="simulacion.Entorno.informacion_json" href="#simulacion.Entorno.informacion_json">informacion_json</a></code></li>
<li><code><a title="simulacion.Entorno.informe_experimento" href="#simulacion.Entorno.informe_experimento">informe_experimento</a></code></li>
<li><code><a title="simulacion.Entorno.quitar_electrodo" href="#simulacion.Entorno.quitar_electrodo">quitar_electrodo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulacion.Estimulador" href="#simulacion.Estimulador">Estimulador</a></code></h4>
<ul class="">
<li><code><a title="simulacion.Estimulador.crear_estimulo" href="#simulacion.Estimulador.crear_estimulo">crear_estimulo</a></code></li>
<li><code><a title="simulacion.Estimulador.estimulo_cuadrado" href="#simulacion.Estimulador.estimulo_cuadrado">estimulo_cuadrado</a></code></li>
<li><code><a title="simulacion.Estimulador.estimulo_desde_archivo" href="#simulacion.Estimulador.estimulo_desde_archivo">estimulo_desde_archivo</a></code></li>
<li><code><a title="simulacion.Estimulador.estimulo_manual" href="#simulacion.Estimulador.estimulo_manual">estimulo_manual</a></code></li>
<li><code><a title="simulacion.Estimulador.potencial_de_accion" href="#simulacion.Estimulador.potencial_de_accion">potencial_de_accion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulacion.Fibra" href="#simulacion.Fibra">Fibra</a></code></h4>
<ul class="">
<li><code><a title="simulacion.Fibra.info_fibra" href="#simulacion.Fibra.info_fibra">info_fibra</a></code></li>
<li><code><a title="simulacion.Fibra.obtener_info_fibra" href="#simulacion.Fibra.obtener_info_fibra">obtener_info_fibra</a></code></li>
<li><code><a title="simulacion.Fibra.ubicar_nodos" href="#simulacion.Fibra.ubicar_nodos">ubicar_nodos</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulacion.FormaDePloteo" href="#simulacion.FormaDePloteo">FormaDePloteo</a></code></h4>
<ul class="">
<li><code><a title="simulacion.FormaDePloteo.fibras_con_diametro" href="#simulacion.FormaDePloteo.fibras_con_diametro">fibras_con_diametro</a></code></li>
<li><code><a title="simulacion.FormaDePloteo.fibras_sin_diametro" href="#simulacion.FormaDePloteo.fibras_sin_diametro">fibras_sin_diametro</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulacion.InputError" href="#simulacion.InputError">InputError</a></code></h4>
</li>
<li>
<h4><code><a title="simulacion.LoadingError" href="#simulacion.LoadingError">LoadingError</a></code></h4>
</li>
<li>
<h4><code><a title="simulacion.MissingParameterError" href="#simulacion.MissingParameterError">MissingParameterError</a></code></h4>
</li>
<li>
<h4><code><a title="simulacion.Nervio" href="#simulacion.Nervio">Nervio</a></code></h4>
<ul class="">
<li><code><a title="simulacion.Nervio.agregar_nodos" href="#simulacion.Nervio.agregar_nodos">agregar_nodos</a></code></li>
<li><code><a title="simulacion.Nervio.desde_archivo" href="#simulacion.Nervio.desde_archivo">desde_archivo</a></code></li>
<li><code><a title="simulacion.Nervio.info_nervio" href="#simulacion.Nervio.info_nervio">info_nervio</a></code></li>
<li><code><a title="simulacion.Nervio.informacion_fibras" href="#simulacion.Nervio.informacion_fibras">informacion_fibras</a></code></li>
<li><code><a title="simulacion.Nervio.manual" href="#simulacion.Nervio.manual">manual</a></code></li>
<li><code><a title="simulacion.Nervio.ploteo_fibras_circulos" href="#simulacion.Nervio.ploteo_fibras_circulos">ploteo_fibras_circulos</a></code></li>
<li><code><a title="simulacion.Nervio.ploteo_fibras_puntos" href="#simulacion.Nervio.ploteo_fibras_puntos">ploteo_fibras_puntos</a></code></li>
<li><code><a title="simulacion.Nervio.poblar" href="#simulacion.Nervio.poblar">poblar</a></code></li>
<li><code><a title="simulacion.Nervio.uniforme_con_superposicion" href="#simulacion.Nervio.uniforme_con_superposicion">uniforme_con_superposicion</a></code></li>
<li><code><a title="simulacion.Nervio.uniforme_sin_suporsicion" href="#simulacion.Nervio.uniforme_sin_suporsicion">uniforme_sin_suporsicion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulacion.ObjectCreationError" href="#simulacion.ObjectCreationError">ObjectCreationError</a></code></h4>
</li>
<li>
<h4><code><a title="simulacion.OutOfBounds" href="#simulacion.OutOfBounds">OutOfBounds</a></code></h4>
</li>
<li>
<h4><code><a title="simulacion.PoblacionNervio" href="#simulacion.PoblacionNervio">PoblacionNervio</a></code></h4>
<ul class="">
<li><code><a title="simulacion.PoblacionNervio.desde_archivo" href="#simulacion.PoblacionNervio.desde_archivo">desde_archivo</a></code></li>
<li><code><a title="simulacion.PoblacionNervio.manual" href="#simulacion.PoblacionNervio.manual">manual</a></code></li>
<li><code><a title="simulacion.PoblacionNervio.uniforme_con_superposicion" href="#simulacion.PoblacionNervio.uniforme_con_superposicion">uniforme_con_superposicion</a></code></li>
<li><code><a title="simulacion.PoblacionNervio.uniforme_sin_superposicion" href="#simulacion.PoblacionNervio.uniforme_sin_superposicion">uniforme_sin_superposicion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulacion.TipoElectrodo" href="#simulacion.TipoElectrodo">TipoElectrodo</a></code></h4>
<ul class="">
<li><code><a title="simulacion.TipoElectrodo.circulo" href="#simulacion.TipoElectrodo.circulo">circulo</a></code></li>
<li><code><a title="simulacion.TipoElectrodo.poligono" href="#simulacion.TipoElectrodo.poligono">poligono</a></code></li>
<li><code><a title="simulacion.TipoElectrodo.punto" href="#simulacion.TipoElectrodo.punto">punto</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulacion.TipoEstimulo" href="#simulacion.TipoEstimulo">TipoEstimulo</a></code></h4>
<ul class="">
<li><code><a title="simulacion.TipoEstimulo.cuadrado" href="#simulacion.TipoEstimulo.cuadrado">cuadrado</a></code></li>
<li><code><a title="simulacion.TipoEstimulo.desde_archivo" href="#simulacion.TipoEstimulo.desde_archivo">desde_archivo</a></code></li>
<li><code><a title="simulacion.TipoEstimulo.manual" href="#simulacion.TipoEstimulo.manual">manual</a></code></li>
<li><code><a title="simulacion.TipoEstimulo.potencial_de_accion" href="#simulacion.TipoEstimulo.potencial_de_accion">potencial_de_accion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulacion.TipoFibra" href="#simulacion.TipoFibra">TipoFibra</a></code></h4>
<ul class="">
<li><code><a title="simulacion.TipoFibra.no_puntual" href="#simulacion.TipoFibra.no_puntual">no_puntual</a></code></li>
<li><code><a title="simulacion.TipoFibra.puntual" href="#simulacion.TipoFibra.puntual">puntual</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulacion.VariacionNodos" href="#simulacion.VariacionNodos">VariacionNodos</a></code></h4>
<ul class="">
<li><code><a title="simulacion.VariacionNodos.normal" href="#simulacion.VariacionNodos.normal">normal</a></code></li>
<li><code><a title="simulacion.VariacionNodos.uniforme" href="#simulacion.VariacionNodos.uniforme">uniforme</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>